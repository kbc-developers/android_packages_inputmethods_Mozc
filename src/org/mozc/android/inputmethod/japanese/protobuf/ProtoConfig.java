// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol/config.proto

package org.mozc.android.inputmethod.japanese.protobuf;

public final class ProtoConfig {
  private ProtoConfig() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  public interface GeneralConfigOrBuilder
      extends com.google.protobuf.MessageOrBuilder {

    // optional uint32 config_version = 1 [default = 0];
    /**
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     *
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     */
    boolean hasConfigVersion();
    /**
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     *
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     */
    int getConfigVersion();

    // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    boolean hasLastModifiedProductVersion();
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    java.lang.String getLastModifiedProductVersion();
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes();

    // optional uint64 last_modified_time = 3 [default = 0];
    /**
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     *
     * <pre>
     * last modified time in UTC second
     * </pre>
     */
    boolean hasLastModifiedTime();
    /**
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     *
     * <pre>
     * last modified time in UTC second
     * </pre>
     */
    long getLastModifiedTime();

    // optional string platform = 4 [default = ""];
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    boolean hasPlatform();
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    java.lang.String getPlatform();
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    com.google.protobuf.ByteString
        getPlatformBytes();

    // optional string ui_locale = 5 [default = ""];
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    boolean hasUiLocale();
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    java.lang.String getUiLocale();
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    com.google.protobuf.ByteString
        getUiLocaleBytes();

    // optional bool upload_usage_stats = 6 [default = false];
    /**
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     *
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     */
    boolean hasUploadUsageStats();
    /**
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     *
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     */
    boolean getUploadUsageStats();
  }
  /**
   * Protobuf type {@code mozc.config.GeneralConfig}
   *
   * <pre>
   *&#47;///////////////////////////////////////////////////////////
   *
   * General config (1-9)
   * </pre>
   */
  public static final class GeneralConfig extends
      com.google.protobuf.GeneratedMessage
      implements GeneralConfigOrBuilder {
    // Use GeneralConfig.newBuilder() to construct.
    private GeneralConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private GeneralConfig(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final GeneralConfig defaultInstance;
    public static GeneralConfig getDefaultInstance() {
      return defaultInstance;
    }

    public GeneralConfig getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private GeneralConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              configVersion_ = input.readUInt32();
              break;
            }
            case 18: {
              bitField0_ |= 0x00000002;
              lastModifiedProductVersion_ = input.readBytes();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              lastModifiedTime_ = input.readUInt64();
              break;
            }
            case 34: {
              bitField0_ |= 0x00000008;
              platform_ = input.readBytes();
              break;
            }
            case 42: {
              bitField0_ |= 0x00000010;
              uiLocale_ = input.readBytes();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000020;
              uploadUsageStats_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
    }

    public static com.google.protobuf.Parser<GeneralConfig> PARSER =
        new com.google.protobuf.AbstractParser<GeneralConfig>() {
      public GeneralConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GeneralConfig(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<GeneralConfig> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    // optional uint32 config_version = 1 [default = 0];
    public static final int CONFIG_VERSION_FIELD_NUMBER = 1;
    private int configVersion_;
    /**
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     *
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     */
    public boolean hasConfigVersion() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional uint32 config_version = 1 [default = 0];</code>
     *
     * <pre>
     * config version, corresponding to the suffix of config file
     * </pre>
     */
    public int getConfigVersion() {
      return configVersion_;
    }

    // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
    public static final int LAST_MODIFIED_PRODUCT_VERSION_FIELD_NUMBER = 2;
    private java.lang.Object lastModifiedProductVersion_;
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    public boolean hasLastModifiedProductVersion() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    public java.lang.String getLastModifiedProductVersion() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          lastModifiedProductVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
     *
     * <pre>
     * The product version that wrote this config
     * </pre>
     */
    public com.google.protobuf.ByteString
        getLastModifiedProductVersionBytes() {
      java.lang.Object ref = lastModifiedProductVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        lastModifiedProductVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional uint64 last_modified_time = 3 [default = 0];
    public static final int LAST_MODIFIED_TIME_FIELD_NUMBER = 3;
    private long lastModifiedTime_;
    /**
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     *
     * <pre>
     * last modified time in UTC second
     * </pre>
     */
    public boolean hasLastModifiedTime() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
     *
     * <pre>
     * last modified time in UTC second
     * </pre>
     */
    public long getLastModifiedTime() {
      return lastModifiedTime_;
    }

    // optional string platform = 4 [default = ""];
    public static final int PLATFORM_FIELD_NUMBER = 4;
    private java.lang.Object platform_;
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    public boolean hasPlatform() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    public java.lang.String getPlatform() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          platform_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string platform = 4 [default = ""];</code>
     *
     * <pre>
     * These fileds are not used now
     * platform of machine that wrote this config
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPlatformBytes() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platform_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional string ui_locale = 5 [default = ""];
    public static final int UI_LOCALE_FIELD_NUMBER = 5;
    private java.lang.Object uiLocale_;
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    public boolean hasUiLocale() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    public java.lang.String getUiLocale() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          uiLocale_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string ui_locale = 5 [default = ""];</code>
     *
     * <pre>
     * UI locale of machine that wrote this config
     * </pre>
     */
    public com.google.protobuf.ByteString
        getUiLocaleBytes() {
      java.lang.Object ref = uiLocale_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        uiLocale_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional bool upload_usage_stats = 6 [default = false];
    public static final int UPLOAD_USAGE_STATS_FIELD_NUMBER = 6;
    private boolean uploadUsageStats_;
    /**
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     *
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     */
    public boolean hasUploadUsageStats() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional bool upload_usage_stats = 6 [default = false];</code>
     *
     * <pre>
     * Whether to upload usage stats
     * This flag is used only for Android.
     * </pre>
     */
    public boolean getUploadUsageStats() {
      return uploadUsageStats_;
    }

    private void initFields() {
      configVersion_ = 0;
      lastModifiedProductVersion_ = "0.0.0.0";
      lastModifiedTime_ = 0L;
      platform_ = "";
      uiLocale_ = "";
      uploadUsageStats_ = false;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized != -1) return isInitialized == 1;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, getLastModifiedProductVersionBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBytes(4, getPlatformBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBytes(5, getUiLocaleBytes());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeBool(6, uploadUsageStats_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, configVersion_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, getLastModifiedProductVersionBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, lastModifiedTime_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, getPlatformBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, getUiLocaleBytes());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, uploadUsageStats_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.config.GeneralConfig}
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * General config (1-9)
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder>
       implements org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        configVersion_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        lastModifiedProductVersion_ = "0.0.0.0";
        bitField0_ = (bitField0_ & ~0x00000002);
        lastModifiedTime_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        platform_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        uiLocale_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        uploadUsageStats_ = false;
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_GeneralConfig_descriptor;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.configVersion_ = configVersion_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.lastModifiedProductVersion_ = lastModifiedProductVersion_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.lastModifiedTime_ = lastModifiedTime_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.platform_ = platform_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.uiLocale_ = uiLocale_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.uploadUsageStats_ = uploadUsageStats_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) return this;
        if (other.hasConfigVersion()) {
          setConfigVersion(other.getConfigVersion());
        }
        if (other.hasLastModifiedProductVersion()) {
          bitField0_ |= 0x00000002;
          lastModifiedProductVersion_ = other.lastModifiedProductVersion_;
          onChanged();
        }
        if (other.hasLastModifiedTime()) {
          setLastModifiedTime(other.getLastModifiedTime());
        }
        if (other.hasPlatform()) {
          bitField0_ |= 0x00000008;
          platform_ = other.platform_;
          onChanged();
        }
        if (other.hasUiLocale()) {
          bitField0_ |= 0x00000010;
          uiLocale_ = other.uiLocale_;
          onChanged();
        }
        if (other.hasUploadUsageStats()) {
          setUploadUsageStats(other.getUploadUsageStats());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      // optional uint32 config_version = 1 [default = 0];
      private int configVersion_ ;
      /**
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       *
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       */
      public boolean hasConfigVersion() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       *
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       */
      public int getConfigVersion() {
        return configVersion_;
      }
      /**
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       *
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       */
      public Builder setConfigVersion(int value) {
        bitField0_ |= 0x00000001;
        configVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 config_version = 1 [default = 0];</code>
       *
       * <pre>
       * config version, corresponding to the suffix of config file
       * </pre>
       */
      public Builder clearConfigVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        configVersion_ = 0;
        onChanged();
        return this;
      }

      // optional string last_modified_product_version = 2 [default = "0.0.0.0"];
      private java.lang.Object lastModifiedProductVersion_ = "0.0.0.0";
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public boolean hasLastModifiedProductVersion() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public java.lang.String getLastModifiedProductVersion() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          lastModifiedProductVersion_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public com.google.protobuf.ByteString
          getLastModifiedProductVersionBytes() {
        java.lang.Object ref = lastModifiedProductVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          lastModifiedProductVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public Builder setLastModifiedProductVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        lastModifiedProductVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public Builder clearLastModifiedProductVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        lastModifiedProductVersion_ = getDefaultInstance().getLastModifiedProductVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string last_modified_product_version = 2 [default = "0.0.0.0"];</code>
       *
       * <pre>
       * The product version that wrote this config
       * </pre>
       */
      public Builder setLastModifiedProductVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        lastModifiedProductVersion_ = value;
        onChanged();
        return this;
      }

      // optional uint64 last_modified_time = 3 [default = 0];
      private long lastModifiedTime_ ;
      /**
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       *
       * <pre>
       * last modified time in UTC second
       * </pre>
       */
      public boolean hasLastModifiedTime() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       *
       * <pre>
       * last modified time in UTC second
       * </pre>
       */
      public long getLastModifiedTime() {
        return lastModifiedTime_;
      }
      /**
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       *
       * <pre>
       * last modified time in UTC second
       * </pre>
       */
      public Builder setLastModifiedTime(long value) {
        bitField0_ |= 0x00000004;
        lastModifiedTime_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 last_modified_time = 3 [default = 0];</code>
       *
       * <pre>
       * last modified time in UTC second
       * </pre>
       */
      public Builder clearLastModifiedTime() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lastModifiedTime_ = 0L;
        onChanged();
        return this;
      }

      // optional string platform = 4 [default = ""];
      private java.lang.Object platform_ = "";
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public boolean hasPlatform() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public java.lang.String getPlatform() {
        java.lang.Object ref = platform_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          platform_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPlatformBytes() {
        java.lang.Object ref = platform_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platform_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public Builder setPlatform(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public Builder clearPlatform() {
        bitField0_ = (bitField0_ & ~0x00000008);
        platform_ = getDefaultInstance().getPlatform();
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform = 4 [default = ""];</code>
       *
       * <pre>
       * These fileds are not used now
       * platform of machine that wrote this config
       * </pre>
       */
      public Builder setPlatformBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }

      // optional string ui_locale = 5 [default = ""];
      private java.lang.Object uiLocale_ = "";
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public boolean hasUiLocale() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public java.lang.String getUiLocale() {
        java.lang.Object ref = uiLocale_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          uiLocale_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public com.google.protobuf.ByteString
          getUiLocaleBytes() {
        java.lang.Object ref = uiLocale_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          uiLocale_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public Builder setUiLocale(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        uiLocale_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public Builder clearUiLocale() {
        bitField0_ = (bitField0_ & ~0x00000010);
        uiLocale_ = getDefaultInstance().getUiLocale();
        onChanged();
        return this;
      }
      /**
       * <code>optional string ui_locale = 5 [default = ""];</code>
       *
       * <pre>
       * UI locale of machine that wrote this config
       * </pre>
       */
      public Builder setUiLocaleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        uiLocale_ = value;
        onChanged();
        return this;
      }

      // optional bool upload_usage_stats = 6 [default = false];
      private boolean uploadUsageStats_ ;
      /**
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       *
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       */
      public boolean hasUploadUsageStats() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       *
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       */
      public boolean getUploadUsageStats() {
        return uploadUsageStats_;
      }
      /**
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       *
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       */
      public Builder setUploadUsageStats(boolean value) {
        bitField0_ |= 0x00000020;
        uploadUsageStats_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool upload_usage_stats = 6 [default = false];</code>
       *
       * <pre>
       * Whether to upload usage stats
       * This flag is used only for Android.
       * </pre>
       */
      public Builder clearUploadUsageStats() {
        bitField0_ = (bitField0_ & ~0x00000020);
        uploadUsageStats_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.config.GeneralConfig)
    }

    static {
      defaultInstance = new GeneralConfig(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:mozc.config.GeneralConfig)
  }

  public interface OBSOLETE_SyncConfigOrBuilder
      extends com.google.protobuf.MessageOrBuilder {

    // optional bool use_config_sync = 1 [default = false];
    /**
     * <code>optional bool use_config_sync = 1 [default = false];</code>
     */
    boolean hasUseConfigSync();
    /**
     * <code>optional bool use_config_sync = 1 [default = false];</code>
     */
    boolean getUseConfigSync();

    // optional bool use_user_dictionary_sync = 2 [default = false];
    /**
     * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
     */
    boolean hasUseUserDictionarySync();
    /**
     * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
     */
    boolean getUseUserDictionarySync();

    // optional bool use_user_history_sync = 3 [default = false];
    /**
     * <code>optional bool use_user_history_sync = 3 [default = false];</code>
     */
    boolean hasUseUserHistorySync();
    /**
     * <code>optional bool use_user_history_sync = 3 [default = false];</code>
     */
    boolean getUseUserHistorySync();

    // optional bool use_learning_preference_sync = 4 [default = false];
    /**
     * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
     */
    boolean hasUseLearningPreferenceSync();
    /**
     * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
     */
    boolean getUseLearningPreferenceSync();

    // optional bool use_contact_list_sync = 5 [default = false];
    /**
     * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
     */
    boolean hasUseContactListSync();
    /**
     * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
     */
    boolean getUseContactListSync();
  }
  /**
   * Protobuf type {@code mozc.config.OBSOLETE_SyncConfig}
   */
  public static final class OBSOLETE_SyncConfig extends
      com.google.protobuf.GeneratedMessage
      implements OBSOLETE_SyncConfigOrBuilder {
    // Use OBSOLETE_SyncConfig.newBuilder() to construct.
    private OBSOLETE_SyncConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private OBSOLETE_SyncConfig(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final OBSOLETE_SyncConfig defaultInstance;
    public static OBSOLETE_SyncConfig getDefaultInstance() {
      return defaultInstance;
    }

    public OBSOLETE_SyncConfig getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private OBSOLETE_SyncConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              useConfigSync_ = input.readBool();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              useUserDictionarySync_ = input.readBool();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              useUserHistorySync_ = input.readBool();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              useLearningPreferenceSync_ = input.readBool();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000010;
              useContactListSync_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_OBSOLETE_SyncConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder.class);
    }

    public static com.google.protobuf.Parser<OBSOLETE_SyncConfig> PARSER =
        new com.google.protobuf.AbstractParser<OBSOLETE_SyncConfig>() {
      public OBSOLETE_SyncConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new OBSOLETE_SyncConfig(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<OBSOLETE_SyncConfig> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    // optional bool use_config_sync = 1 [default = false];
    public static final int USE_CONFIG_SYNC_FIELD_NUMBER = 1;
    private boolean useConfigSync_;
    /**
     * <code>optional bool use_config_sync = 1 [default = false];</code>
     */
    public boolean hasUseConfigSync() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional bool use_config_sync = 1 [default = false];</code>
     */
    public boolean getUseConfigSync() {
      return useConfigSync_;
    }

    // optional bool use_user_dictionary_sync = 2 [default = false];
    public static final int USE_USER_DICTIONARY_SYNC_FIELD_NUMBER = 2;
    private boolean useUserDictionarySync_;
    /**
     * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
     */
    public boolean hasUseUserDictionarySync() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
     */
    public boolean getUseUserDictionarySync() {
      return useUserDictionarySync_;
    }

    // optional bool use_user_history_sync = 3 [default = false];
    public static final int USE_USER_HISTORY_SYNC_FIELD_NUMBER = 3;
    private boolean useUserHistorySync_;
    /**
     * <code>optional bool use_user_history_sync = 3 [default = false];</code>
     */
    public boolean hasUseUserHistorySync() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional bool use_user_history_sync = 3 [default = false];</code>
     */
    public boolean getUseUserHistorySync() {
      return useUserHistorySync_;
    }

    // optional bool use_learning_preference_sync = 4 [default = false];
    public static final int USE_LEARNING_PREFERENCE_SYNC_FIELD_NUMBER = 4;
    private boolean useLearningPreferenceSync_;
    /**
     * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
     */
    public boolean hasUseLearningPreferenceSync() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
     */
    public boolean getUseLearningPreferenceSync() {
      return useLearningPreferenceSync_;
    }

    // optional bool use_contact_list_sync = 5 [default = false];
    public static final int USE_CONTACT_LIST_SYNC_FIELD_NUMBER = 5;
    private boolean useContactListSync_;
    /**
     * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
     */
    public boolean hasUseContactListSync() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
     */
    public boolean getUseContactListSync() {
      return useContactListSync_;
    }

    private void initFields() {
      useConfigSync_ = false;
      useUserDictionarySync_ = false;
      useUserHistorySync_ = false;
      useLearningPreferenceSync_ = false;
      useContactListSync_ = false;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized != -1) return isInitialized == 1;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBool(1, useConfigSync_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBool(2, useUserDictionarySync_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(3, useUserHistorySync_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(4, useLearningPreferenceSync_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(5, useContactListSync_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, useConfigSync_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, useUserDictionarySync_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, useUserHistorySync_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, useLearningPreferenceSync_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, useContactListSync_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.config.OBSOLETE_SyncConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder>
       implements org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_OBSOLETE_SyncConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        useConfigSync_ = false;
        bitField0_ = (bitField0_ & ~0x00000001);
        useUserDictionarySync_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        useUserHistorySync_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        useLearningPreferenceSync_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        useContactListSync_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance();
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.useConfigSync_ = useConfigSync_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.useUserDictionarySync_ = useUserDictionarySync_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.useUserHistorySync_ = useUserHistorySync_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.useLearningPreferenceSync_ = useLearningPreferenceSync_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.useContactListSync_ = useContactListSync_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance()) return this;
        if (other.hasUseConfigSync()) {
          setUseConfigSync(other.getUseConfigSync());
        }
        if (other.hasUseUserDictionarySync()) {
          setUseUserDictionarySync(other.getUseUserDictionarySync());
        }
        if (other.hasUseUserHistorySync()) {
          setUseUserHistorySync(other.getUseUserHistorySync());
        }
        if (other.hasUseLearningPreferenceSync()) {
          setUseLearningPreferenceSync(other.getUseLearningPreferenceSync());
        }
        if (other.hasUseContactListSync()) {
          setUseContactListSync(other.getUseContactListSync());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      // optional bool use_config_sync = 1 [default = false];
      private boolean useConfigSync_ ;
      /**
       * <code>optional bool use_config_sync = 1 [default = false];</code>
       */
      public boolean hasUseConfigSync() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bool use_config_sync = 1 [default = false];</code>
       */
      public boolean getUseConfigSync() {
        return useConfigSync_;
      }
      /**
       * <code>optional bool use_config_sync = 1 [default = false];</code>
       */
      public Builder setUseConfigSync(boolean value) {
        bitField0_ |= 0x00000001;
        useConfigSync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_config_sync = 1 [default = false];</code>
       */
      public Builder clearUseConfigSync() {
        bitField0_ = (bitField0_ & ~0x00000001);
        useConfigSync_ = false;
        onChanged();
        return this;
      }

      // optional bool use_user_dictionary_sync = 2 [default = false];
      private boolean useUserDictionarySync_ ;
      /**
       * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
       */
      public boolean hasUseUserDictionarySync() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
       */
      public boolean getUseUserDictionarySync() {
        return useUserDictionarySync_;
      }
      /**
       * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
       */
      public Builder setUseUserDictionarySync(boolean value) {
        bitField0_ |= 0x00000002;
        useUserDictionarySync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_user_dictionary_sync = 2 [default = false];</code>
       */
      public Builder clearUseUserDictionarySync() {
        bitField0_ = (bitField0_ & ~0x00000002);
        useUserDictionarySync_ = false;
        onChanged();
        return this;
      }

      // optional bool use_user_history_sync = 3 [default = false];
      private boolean useUserHistorySync_ ;
      /**
       * <code>optional bool use_user_history_sync = 3 [default = false];</code>
       */
      public boolean hasUseUserHistorySync() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional bool use_user_history_sync = 3 [default = false];</code>
       */
      public boolean getUseUserHistorySync() {
        return useUserHistorySync_;
      }
      /**
       * <code>optional bool use_user_history_sync = 3 [default = false];</code>
       */
      public Builder setUseUserHistorySync(boolean value) {
        bitField0_ |= 0x00000004;
        useUserHistorySync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_user_history_sync = 3 [default = false];</code>
       */
      public Builder clearUseUserHistorySync() {
        bitField0_ = (bitField0_ & ~0x00000004);
        useUserHistorySync_ = false;
        onChanged();
        return this;
      }

      // optional bool use_learning_preference_sync = 4 [default = false];
      private boolean useLearningPreferenceSync_ ;
      /**
       * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
       */
      public boolean hasUseLearningPreferenceSync() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
       */
      public boolean getUseLearningPreferenceSync() {
        return useLearningPreferenceSync_;
      }
      /**
       * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
       */
      public Builder setUseLearningPreferenceSync(boolean value) {
        bitField0_ |= 0x00000008;
        useLearningPreferenceSync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_learning_preference_sync = 4 [default = false];</code>
       */
      public Builder clearUseLearningPreferenceSync() {
        bitField0_ = (bitField0_ & ~0x00000008);
        useLearningPreferenceSync_ = false;
        onChanged();
        return this;
      }

      // optional bool use_contact_list_sync = 5 [default = false];
      private boolean useContactListSync_ ;
      /**
       * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
       */
      public boolean hasUseContactListSync() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
       */
      public boolean getUseContactListSync() {
        return useContactListSync_;
      }
      /**
       * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
       */
      public Builder setUseContactListSync(boolean value) {
        bitField0_ |= 0x00000010;
        useContactListSync_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_contact_list_sync = 5 [default = false];</code>
       */
      public Builder clearUseContactListSync() {
        bitField0_ = (bitField0_ & ~0x00000010);
        useContactListSync_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.config.OBSOLETE_SyncConfig)
    }

    static {
      defaultInstance = new OBSOLETE_SyncConfig(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:mozc.config.OBSOLETE_SyncConfig)
  }

  public interface ConfigOrBuilder
      extends com.google.protobuf.MessageOrBuilder {

    // optional .mozc.config.GeneralConfig general_config = 1;
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    boolean hasGeneralConfig();
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig();
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder();

    // optional int32 verbose_level = 10 [default = 0];
    /**
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     *
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     */
    boolean hasVerboseLevel();
    /**
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     *
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     */
    int getVerboseLevel();

    // optional bool DEPRECATED_log_all_commands = 11 [default = false];
    /**
     * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
     *
     * <pre>
     * This flag is not used
     * </pre>
     */
    boolean hasDEPRECATEDLogAllCommands();
    /**
     * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
     *
     * <pre>
     * This flag is not used
     * </pre>
     */
    boolean getDEPRECATEDLogAllCommands();

    // optional bool incognito_mode = 20 [default = false];
    /**
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     *
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     */
    boolean hasIncognitoMode();
    /**
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     *
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     */
    boolean getIncognitoMode();

    // optional bool check_default = 22 [default = true];
    /**
     * <code>optional bool check_default = 22 [default = true];</code>
     *
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     */
    boolean hasCheckDefault();
    /**
     * <code>optional bool check_default = 22 [default = true];</code>
     *
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     */
    boolean getCheckDefault();

    // optional bool presentation_mode = 23 [default = false];
    /**
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     *
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     */
    boolean hasPresentationMode();
    /**
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     *
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     */
    boolean getPresentationMode();

    // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
    /**
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     *
     * <pre>
     * Roman/Kana
     * </pre>
     */
    boolean hasPreeditMethod();
    /**
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     *
     * <pre>
     * Roman/Kana
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod();

    // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    boolean hasSessionKeymap();
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap();

    // optional bytes custom_keymap_table = 42;
    /**
     * <code>optional bytes custom_keymap_table = 42;</code>
     *
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     */
    boolean hasCustomKeymapTable();
    /**
     * <code>optional bytes custom_keymap_table = 42;</code>
     *
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     */
    com.google.protobuf.ByteString getCustomKeymapTable();

    // optional bytes custom_roman_table = 43;
    /**
     * <code>optional bytes custom_roman_table = 43;</code>
     *
     * <pre>
     * custom roman table
     * </pre>
     */
    boolean hasCustomRomanTable();
    /**
     * <code>optional bytes custom_roman_table = 43;</code>
     *
     * <pre>
     * custom roman table
     * </pre>
     */
    com.google.protobuf.ByteString getCustomRomanTable();

    // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    boolean hasPunctuationMethod();
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod();

    // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    boolean hasSymbolMethod();
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod();

    // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    boolean hasSpaceCharacterForm();
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm();

    // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
    /**
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     *
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     *
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     */
    boolean hasUseKeyboardToChangePreeditMethod();
    /**
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     *
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     *
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     */
    boolean getUseKeyboardToChangePreeditMethod();

    // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    boolean hasHistoryLearningLevel();
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel();

    // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    boolean hasSelectionShortcut();
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut();

    // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> 
        getCharacterFormRulesList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index);
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    int getCharacterFormRulesCount();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList();
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index);

    // optional bool use_auto_ime_turn_off = 56 [default = true];
    /**
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     *
     * <pre>
     * auto IME turn off feature
     * </pre>
     */
    boolean hasUseAutoImeTurnOff();
    /**
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     *
     * <pre>
     * auto IME turn off feature
     * </pre>
     */
    boolean getUseAutoImeTurnOff();

    // optional bool use_cascading_window = 58 [default = true];
    /**
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     *
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     */
    boolean hasUseCascadingWindow();
    /**
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     *
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     */
    boolean getUseCascadingWindow();

    // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    boolean hasShiftKeyModeSwitch();
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch();

    // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    boolean hasNumpadCharacterForm();
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm();

    // optional bool use_auto_conversion = 61 [default = false];
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    boolean hasUseAutoConversion();
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    boolean getUseAutoConversion();

    // optional uint32 auto_conversion_key = 62 [default = 13];
    /**
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     *
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     */
    boolean hasAutoConversionKey();
    /**
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     *
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     */
    int getAutoConversionKey();

    // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
    /**
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     *
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     */
    boolean hasYenSignCharacter();
    /**
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     *
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter();

    // optional bool use_japanese_layout = 64 [default = false];
    /**
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     *
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     */
    boolean hasUseJapaneseLayout();
    /**
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     *
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     */
    boolean getUseJapaneseLayout();

    // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
    /**
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     *
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     */
    boolean hasUseKanaModifierInsensitiveConversion();
    /**
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     *
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     */
    boolean getUseKanaModifierInsensitiveConversion();

    // optional bool use_typing_correction = 66 [default = false];
    /**
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     *
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     */
    boolean hasUseTypingCorrection();
    /**
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     *
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     */
    boolean getUseTypingCorrection();

    // optional bool use_date_conversion = 80 [default = true];
    /**
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Dictionary (80-99)
     * </pre>
     */
    boolean hasUseDateConversion();
    /**
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Dictionary (80-99)
     * </pre>
     */
    boolean getUseDateConversion();

    // optional bool use_single_kanji_conversion = 81 [default = true];
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    boolean hasUseSingleKanjiConversion();
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    boolean getUseSingleKanjiConversion();

    // optional bool use_symbol_conversion = 82 [default = true];
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    boolean hasUseSymbolConversion();
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    boolean getUseSymbolConversion();

    // optional bool use_number_conversion = 83 [default = true];
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    boolean hasUseNumberConversion();
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    boolean getUseNumberConversion();

    // optional bool use_emoticon_conversion = 84 [default = true];
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    boolean hasUseEmoticonConversion();
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    boolean getUseEmoticonConversion();

    // optional bool use_calculator = 85 [default = true];
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    boolean hasUseCalculator();
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    boolean getUseCalculator();

    // optional bool use_t13n_conversion = 86 [default = true];
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    boolean hasUseT13NConversion();
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    boolean getUseT13NConversion();

    // optional bool use_zip_code_conversion = 87 [default = true];
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    boolean hasUseZipCodeConversion();
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    boolean getUseZipCodeConversion();

    // optional bool use_spelling_correction = 88 [default = true];
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    boolean hasUseSpellingCorrection();
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    boolean getUseSpellingCorrection();

    // optional bool use_emoji_conversion = 89 [default = false];
    /**
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    boolean hasUseEmojiConversion();
    /**
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    boolean getUseEmojiConversion();

    // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    boolean hasInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig();
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder();

    // optional bool use_history_suggest = 100 [default = true];
    /**
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Suggest (100-119)
     *
     * Use history-based suggest feature.
     * </pre>
     */
    boolean hasUseHistorySuggest();
    /**
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Suggest (100-119)
     *
     * Use history-based suggest feature.
     * </pre>
     */
    boolean getUseHistorySuggest();

    // optional bool use_dictionary_suggest = 101 [default = true];
    /**
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     *
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     */
    boolean hasUseDictionarySuggest();
    /**
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     *
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     */
    boolean getUseDictionarySuggest();

    // optional bool use_realtime_conversion = 102 [default = true];
    /**
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     *
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     */
    boolean hasUseRealtimeConversion();
    /**
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     *
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     */
    boolean getUseRealtimeConversion();

    // optional uint32 suggestions_size = 110 [default = 3];
    /**
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     *
     * <pre>
     * Size of suggestions.
     * </pre>
     */
    boolean hasSuggestionsSize();
    /**
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     *
     * <pre>
     * Size of suggestions.
     * </pre>
     */
    int getSuggestionsSize();

    // optional bool use_mode_indicator = 120 [default = true];
    /**
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Renderer (120-139)
     *
     * Use mode indicator feature.
     * </pre>
     */
    boolean hasUseModeIndicator();
    /**
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Renderer (120-139)
     *
     * Use mode indicator feature.
     * </pre>
     */
    boolean getUseModeIndicator();

    // optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    boolean hasOBSOLETESyncConfig();
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig getOBSOLETESyncConfig();
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder getOBSOLETESyncConfigOrBuilder();

    // optional bool allow_cloud_handwriting = 301 [default = false];
    /**
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     *
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     */
    boolean hasAllowCloudHandwriting();
    /**
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     *
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     */
    boolean getAllowCloudHandwriting();
  }
  /**
   * Protobuf type {@code mozc.config.Config}
   */
  public static final class Config extends
      com.google.protobuf.GeneratedMessage
      implements ConfigOrBuilder {
    // Use Config.newBuilder() to construct.
    private Config(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private Config(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final Config defaultInstance;
    public static Config getDefaultInstance() {
      return defaultInstance;
    }

    public Config getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private Config(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = generalConfig_.toBuilder();
              }
              generalConfig_ = input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(generalConfig_);
                generalConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 80: {
              bitField0_ |= 0x00000002;
              verboseLevel_ = input.readInt32();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000004;
              dEPRECATEDLogAllCommands_ = input.readBool();
              break;
            }
            case 160: {
              bitField0_ |= 0x00000008;
              incognitoMode_ = input.readBool();
              break;
            }
            case 176: {
              bitField0_ |= 0x00000010;
              checkDefault_ = input.readBool();
              break;
            }
            case 184: {
              bitField0_ |= 0x00000020;
              presentationMode_ = input.readBool();
              break;
            }
            case 320: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(40, rawValue);
              } else {
                bitField0_ |= 0x00000040;
                preeditMethod_ = value;
              }
              break;
            }
            case 328: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(41, rawValue);
              } else {
                bitField0_ |= 0x00000080;
                sessionKeymap_ = value;
              }
              break;
            }
            case 338: {
              bitField0_ |= 0x00000100;
              customKeymapTable_ = input.readBytes();
              break;
            }
            case 346: {
              bitField0_ |= 0x00000200;
              customRomanTable_ = input.readBytes();
              break;
            }
            case 360: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(45, rawValue);
              } else {
                bitField0_ |= 0x00000400;
                punctuationMethod_ = value;
              }
              break;
            }
            case 368: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(46, rawValue);
              } else {
                bitField0_ |= 0x00000800;
                symbolMethod_ = value;
              }
              break;
            }
            case 376: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(47, rawValue);
              } else {
                bitField0_ |= 0x00001000;
                spaceCharacterForm_ = value;
              }
              break;
            }
            case 384: {
              bitField0_ |= 0x00002000;
              useKeyboardToChangePreeditMethod_ = input.readBool();
              break;
            }
            case 400: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(50, rawValue);
              } else {
                bitField0_ |= 0x00004000;
                historyLearningLevel_ = value;
              }
              break;
            }
            case 416: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(52, rawValue);
              } else {
                bitField0_ |= 0x00008000;
                selectionShortcut_ = value;
              }
              break;
            }
            case 434: {
              if (!((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
                characterFormRules_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>();
                mutable_bitField0_ |= 0x00010000;
              }
              characterFormRules_.add(input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.PARSER, extensionRegistry));
              break;
            }
            case 448: {
              bitField0_ |= 0x00010000;
              useAutoImeTurnOff_ = input.readBool();
              break;
            }
            case 464: {
              bitField0_ |= 0x00020000;
              useCascadingWindow_ = input.readBool();
              break;
            }
            case 472: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(59, rawValue);
              } else {
                bitField0_ |= 0x00040000;
                shiftKeyModeSwitch_ = value;
              }
              break;
            }
            case 480: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(60, rawValue);
              } else {
                bitField0_ |= 0x00080000;
                numpadCharacterForm_ = value;
              }
              break;
            }
            case 488: {
              bitField0_ |= 0x00100000;
              useAutoConversion_ = input.readBool();
              break;
            }
            case 496: {
              bitField0_ |= 0x00200000;
              autoConversionKey_ = input.readUInt32();
              break;
            }
            case 504: {
              int rawValue = input.readEnum();
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(63, rawValue);
              } else {
                bitField0_ |= 0x00400000;
                yenSignCharacter_ = value;
              }
              break;
            }
            case 512: {
              bitField0_ |= 0x00800000;
              useJapaneseLayout_ = input.readBool();
              break;
            }
            case 520: {
              bitField0_ |= 0x01000000;
              useKanaModifierInsensitiveConversion_ = input.readBool();
              break;
            }
            case 528: {
              bitField0_ |= 0x02000000;
              useTypingCorrection_ = input.readBool();
              break;
            }
            case 640: {
              bitField0_ |= 0x04000000;
              useDateConversion_ = input.readBool();
              break;
            }
            case 648: {
              bitField0_ |= 0x08000000;
              useSingleKanjiConversion_ = input.readBool();
              break;
            }
            case 656: {
              bitField0_ |= 0x10000000;
              useSymbolConversion_ = input.readBool();
              break;
            }
            case 664: {
              bitField0_ |= 0x20000000;
              useNumberConversion_ = input.readBool();
              break;
            }
            case 672: {
              bitField0_ |= 0x40000000;
              useEmoticonConversion_ = input.readBool();
              break;
            }
            case 680: {
              bitField0_ |= 0x80000000;
              useCalculator_ = input.readBool();
              break;
            }
            case 688: {
              bitField1_ |= 0x00000001;
              useT13NConversion_ = input.readBool();
              break;
            }
            case 696: {
              bitField1_ |= 0x00000002;
              useZipCodeConversion_ = input.readBool();
              break;
            }
            case 704: {
              bitField1_ |= 0x00000004;
              useSpellingCorrection_ = input.readBool();
              break;
            }
            case 712: {
              bitField1_ |= 0x00000008;
              useEmojiConversion_ = input.readBool();
              break;
            }
            case 722: {
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder subBuilder = null;
              if (((bitField1_ & 0x00000010) == 0x00000010)) {
                subBuilder = informationListConfig_.toBuilder();
              }
              informationListConfig_ = input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(informationListConfig_);
                informationListConfig_ = subBuilder.buildPartial();
              }
              bitField1_ |= 0x00000010;
              break;
            }
            case 800: {
              bitField1_ |= 0x00000020;
              useHistorySuggest_ = input.readBool();
              break;
            }
            case 808: {
              bitField1_ |= 0x00000040;
              useDictionarySuggest_ = input.readBool();
              break;
            }
            case 816: {
              bitField1_ |= 0x00000080;
              useRealtimeConversion_ = input.readBool();
              break;
            }
            case 880: {
              bitField1_ |= 0x00000100;
              suggestionsSize_ = input.readUInt32();
              break;
            }
            case 960: {
              bitField1_ |= 0x00000200;
              useModeIndicator_ = input.readBool();
              break;
            }
            case 2402: {
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder subBuilder = null;
              if (((bitField1_ & 0x00000400) == 0x00000400)) {
                subBuilder = oBSOLETESyncConfig_.toBuilder();
              }
              oBSOLETESyncConfig_ = input.readMessage(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oBSOLETESyncConfig_);
                oBSOLETESyncConfig_ = subBuilder.buildPartial();
              }
              bitField1_ |= 0x00000400;
              break;
            }
            case 2408: {
              bitField1_ |= 0x00000800;
              allowCloudHandwriting_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
          characterFormRules_ = java.util.Collections.unmodifiableList(characterFormRules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
    }

    public static com.google.protobuf.Parser<Config> PARSER =
        new com.google.protobuf.AbstractParser<Config>() {
      public Config parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Config(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<Config> getParserForType() {
      return PARSER;
    }

    /**
     * Protobuf enum {@code mozc.config.Config.PreeditMethod}
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Basic features (40-79)
     * </pre>
     */
    public enum PreeditMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>ROMAN = 0;</code>
       */
      ROMAN(0, 0),
      /**
       * <code>KANA = 1;</code>
       */
      KANA(1, 1),
      ;

      /**
       * <code>ROMAN = 0;</code>
       */
      public static final int ROMAN_VALUE = 0;
      /**
       * <code>KANA = 1;</code>
       */
      public static final int KANA_VALUE = 1;


      public final int getNumber() { return value; }

      public static PreeditMethod valueOf(int value) {
        switch (value) {
          case 0: return ROMAN;
          case 1: return KANA;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PreeditMethod>() {
              public PreeditMethod findValueByNumber(int number) {
                return PreeditMethod.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(0);
      }

      private static final PreeditMethod[] VALUES = values();

      public static PreeditMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private PreeditMethod(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PreeditMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SessionKeymap}
     */
    public enum SessionKeymap
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NONE = -1;</code>
       *
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       */
      NONE(0, -1),
      /**
       * <code>CUSTOM = 0;</code>
       */
      CUSTOM(1, 0),
      /**
       * <code>ATOK = 1;</code>
       */
      ATOK(2, 1),
      /**
       * <code>MSIME = 2;</code>
       */
      MSIME(3, 2),
      /**
       * <code>KOTOERI = 3;</code>
       */
      KOTOERI(4, 3),
      /**
       * <code>MOBILE = 4;</code>
       */
      MOBILE(5, 4),
      /**
       * <code>CHROMEOS = 5;</code>
       */
      CHROMEOS(6, 5),
      ;

      /**
       * <code>NONE = -1;</code>
       *
       * <pre>
       * If NONE is selected, it will be replaced with MSIME or KOTOERI.
       * NONE is used only for a placeholder, so a configuration program
       * should not show NONE as one of selections.  NONE should be the
       * last of the items due to the limitation of the Qt GUI's
       * implementation. Note that keymap number should be correspoinding
       * to the index of QComboBox in config dialog. Since NONE is not
       * used, we set -1 here.
       * </pre>
       */
      public static final int NONE_VALUE = -1;
      /**
       * <code>CUSTOM = 0;</code>
       */
      public static final int CUSTOM_VALUE = 0;
      /**
       * <code>ATOK = 1;</code>
       */
      public static final int ATOK_VALUE = 1;
      /**
       * <code>MSIME = 2;</code>
       */
      public static final int MSIME_VALUE = 2;
      /**
       * <code>KOTOERI = 3;</code>
       */
      public static final int KOTOERI_VALUE = 3;
      /**
       * <code>MOBILE = 4;</code>
       */
      public static final int MOBILE_VALUE = 4;
      /**
       * <code>CHROMEOS = 5;</code>
       */
      public static final int CHROMEOS_VALUE = 5;


      public final int getNumber() { return value; }

      public static SessionKeymap valueOf(int value) {
        switch (value) {
          case -1: return NONE;
          case 0: return CUSTOM;
          case 1: return ATOK;
          case 2: return MSIME;
          case 3: return KOTOERI;
          case 4: return MOBILE;
          case 5: return CHROMEOS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionKeymap>() {
              public SessionKeymap findValueByNumber(int number) {
                return SessionKeymap.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(1);
      }

      private static final SessionKeymap[] VALUES = values();

      public static SessionKeymap valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private SessionKeymap(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SessionKeymap)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.PunctuationMethod}
     */
    public enum PunctuationMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      KUTEN_TOUTEN(0, 0),
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      COMMA_PERIOD(1, 1),
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      KUTEN_PERIOD(2, 2),
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      COMMA_TOUTEN(3, 3),
      ;

      /**
       * <code>KUTEN_TOUTEN = 0;</code>
       */
      public static final int KUTEN_TOUTEN_VALUE = 0;
      /**
       * <code>COMMA_PERIOD = 1;</code>
       */
      public static final int COMMA_PERIOD_VALUE = 1;
      /**
       * <code>KUTEN_PERIOD = 2;</code>
       */
      public static final int KUTEN_PERIOD_VALUE = 2;
      /**
       * <code>COMMA_TOUTEN = 3;</code>
       */
      public static final int COMMA_TOUTEN_VALUE = 3;


      public final int getNumber() { return value; }

      public static PunctuationMethod valueOf(int value) {
        switch (value) {
          case 0: return KUTEN_TOUTEN;
          case 1: return COMMA_PERIOD;
          case 2: return KUTEN_PERIOD;
          case 3: return COMMA_TOUTEN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<PunctuationMethod>() {
              public PunctuationMethod findValueByNumber(int number) {
                return PunctuationMethod.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(2);
      }

      private static final PunctuationMethod[] VALUES = values();

      public static PunctuationMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private PunctuationMethod(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.PunctuationMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SymbolMethod}
     */
    public enum SymbolMethod
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      CORNER_BRACKET_MIDDLE_DOT(0, 0),
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      SQUARE_BRACKET_SLASH(1, 1),
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      CORNER_BRACKET_SLASH(2, 2),
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      SQUARE_BRACKET_MIDDLE_DOT(3, 3),
      ;

      /**
       * <code>CORNER_BRACKET_MIDDLE_DOT = 0;</code>
       */
      public static final int CORNER_BRACKET_MIDDLE_DOT_VALUE = 0;
      /**
       * <code>SQUARE_BRACKET_SLASH = 1;</code>
       */
      public static final int SQUARE_BRACKET_SLASH_VALUE = 1;
      /**
       * <code>CORNER_BRACKET_SLASH = 2;</code>
       */
      public static final int CORNER_BRACKET_SLASH_VALUE = 2;
      /**
       * <code>SQUARE_BRACKET_MIDDLE_DOT = 3;</code>
       */
      public static final int SQUARE_BRACKET_MIDDLE_DOT_VALUE = 3;


      public final int getNumber() { return value; }

      public static SymbolMethod valueOf(int value) {
        switch (value) {
          case 0: return CORNER_BRACKET_MIDDLE_DOT;
          case 1: return SQUARE_BRACKET_SLASH;
          case 2: return CORNER_BRACKET_SLASH;
          case 3: return SQUARE_BRACKET_MIDDLE_DOT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SymbolMethod>() {
              public SymbolMethod findValueByNumber(int number) {
                return SymbolMethod.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(3);
      }

      private static final SymbolMethod[] VALUES = values();

      public static SymbolMethod valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private SymbolMethod(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SymbolMethod)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.FundamentalCharacterForm}
     */
    public enum FundamentalCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       *
       * <pre>
       * follow the input mode
       * </pre>
       */
      FUNDAMENTAL_INPUT_MODE(0, 0),
      /**
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       *
       * <pre>
       * always FullWidth
       * </pre>
       */
      FUNDAMENTAL_FULL_WIDTH(1, 1),
      /**
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       *
       * <pre>
       * always HalfWidth
       * </pre>
       */
      FUNDAMENTAL_HALF_WIDTH(2, 2),
      ;

      /**
       * <code>FUNDAMENTAL_INPUT_MODE = 0;</code>
       *
       * <pre>
       * follow the input mode
       * </pre>
       */
      public static final int FUNDAMENTAL_INPUT_MODE_VALUE = 0;
      /**
       * <code>FUNDAMENTAL_FULL_WIDTH = 1;</code>
       *
       * <pre>
       * always FullWidth
       * </pre>
       */
      public static final int FUNDAMENTAL_FULL_WIDTH_VALUE = 1;
      /**
       * <code>FUNDAMENTAL_HALF_WIDTH = 2;</code>
       *
       * <pre>
       * always HalfWidth
       * </pre>
       */
      public static final int FUNDAMENTAL_HALF_WIDTH_VALUE = 2;


      public final int getNumber() { return value; }

      public static FundamentalCharacterForm valueOf(int value) {
        switch (value) {
          case 0: return FUNDAMENTAL_INPUT_MODE;
          case 1: return FUNDAMENTAL_FULL_WIDTH;
          case 2: return FUNDAMENTAL_HALF_WIDTH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FundamentalCharacterForm>() {
              public FundamentalCharacterForm findValueByNumber(int number) {
                return FundamentalCharacterForm.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(4);
      }

      private static final FundamentalCharacterForm[] VALUES = values();

      public static FundamentalCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private FundamentalCharacterForm(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.FundamentalCharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.HistoryLearningLevel}
     *
     * <pre>
     * User history learning
     * </pre>
     */
    public enum HistoryLearningLevel
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      DEFAULT_HISTORY(0, 0),
      /**
       * <code>READ_ONLY = 1;</code>
       */
      READ_ONLY(1, 1),
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      NO_HISTORY(2, 2),
      ;

      /**
       * <code>DEFAULT_HISTORY = 0;</code>
       */
      public static final int DEFAULT_HISTORY_VALUE = 0;
      /**
       * <code>READ_ONLY = 1;</code>
       */
      public static final int READ_ONLY_VALUE = 1;
      /**
       * <code>NO_HISTORY = 2;</code>
       */
      public static final int NO_HISTORY_VALUE = 2;


      public final int getNumber() { return value; }

      public static HistoryLearningLevel valueOf(int value) {
        switch (value) {
          case 0: return DEFAULT_HISTORY;
          case 1: return READ_ONLY;
          case 2: return NO_HISTORY;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<HistoryLearningLevel>() {
              public HistoryLearningLevel findValueByNumber(int number) {
                return HistoryLearningLevel.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(5);
      }

      private static final HistoryLearningLevel[] VALUES = values();

      public static HistoryLearningLevel valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private HistoryLearningLevel(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.HistoryLearningLevel)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.SelectionShortcut}
     */
    public enum SelectionShortcut
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      NO_SHORTCUT(0, 0),
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      SHORTCUT_123456789(1, 1),
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      SHORTCUT_ASDFGHJKL(2, 2),
      ;

      /**
       * <code>NO_SHORTCUT = 0;</code>
       */
      public static final int NO_SHORTCUT_VALUE = 0;
      /**
       * <code>SHORTCUT_123456789 = 1;</code>
       */
      public static final int SHORTCUT_123456789_VALUE = 1;
      /**
       * <code>SHORTCUT_ASDFGHJKL = 2;</code>
       */
      public static final int SHORTCUT_ASDFGHJKL_VALUE = 2;


      public final int getNumber() { return value; }

      public static SelectionShortcut valueOf(int value) {
        switch (value) {
          case 0: return NO_SHORTCUT;
          case 1: return SHORTCUT_123456789;
          case 2: return SHORTCUT_ASDFGHJKL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SelectionShortcut>() {
              public SelectionShortcut findValueByNumber(int number) {
                return SelectionShortcut.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(6);
      }

      private static final SelectionShortcut[] VALUES = values();

      public static SelectionShortcut valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private SelectionShortcut(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.SelectionShortcut)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.CharacterForm}
     *
     * <pre>
     * character form (Halfwidth/Fullwidth
     * </pre>
     */
    public enum CharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      HALF_WIDTH(0, 0),
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      FULL_WIDTH(1, 1),
      /**
       * <code>LAST_FORM = 2;</code>
       */
      LAST_FORM(2, 2),
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      NO_CONVERSION(3, 3),
      ;

      /**
       * <code>HALF_WIDTH = 0;</code>
       */
      public static final int HALF_WIDTH_VALUE = 0;
      /**
       * <code>FULL_WIDTH = 1;</code>
       */
      public static final int FULL_WIDTH_VALUE = 1;
      /**
       * <code>LAST_FORM = 2;</code>
       */
      public static final int LAST_FORM_VALUE = 2;
      /**
       * <code>NO_CONVERSION = 3;</code>
       */
      public static final int NO_CONVERSION_VALUE = 3;


      public final int getNumber() { return value; }

      public static CharacterForm valueOf(int value) {
        switch (value) {
          case 0: return HALF_WIDTH;
          case 1: return FULL_WIDTH;
          case 2: return LAST_FORM;
          case 3: return NO_CONVERSION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<CharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<CharacterForm>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<CharacterForm>() {
              public CharacterForm findValueByNumber(int number) {
                return CharacterForm.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(7);
      }

      private static final CharacterForm[] VALUES = values();

      public static CharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private CharacterForm(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.CharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.ShiftKeyModeSwitch}
     *
     * <pre>
     * Shift key mode switch
     * </pre>
     */
    public enum ShiftKeyModeSwitch
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>OFF = 0;</code>
       *
       * <pre>
       * Case insensitive
       * </pre>
       */
      OFF(0, 0),
      /**
       * <code>ASCII_INPUT_MODE = 1;</code>
       *
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       */
      ASCII_INPUT_MODE(1, 1),
      /**
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       *
       * <pre>
       * Kotoeri behavior
       * </pre>
       */
      KATAKANA_INPUT_MODE(2, 2),
      ;

      /**
       * <code>OFF = 0;</code>
       *
       * <pre>
       * Case insensitive
       * </pre>
       */
      public static final int OFF_VALUE = 0;
      /**
       * <code>ASCII_INPUT_MODE = 1;</code>
       *
       * <pre>
       * MSIME, ATOK behavior
       * </pre>
       */
      public static final int ASCII_INPUT_MODE_VALUE = 1;
      /**
       * <code>KATAKANA_INPUT_MODE = 2;</code>
       *
       * <pre>
       * Kotoeri behavior
       * </pre>
       */
      public static final int KATAKANA_INPUT_MODE_VALUE = 2;


      public final int getNumber() { return value; }

      public static ShiftKeyModeSwitch valueOf(int value) {
        switch (value) {
          case 0: return OFF;
          case 1: return ASCII_INPUT_MODE;
          case 2: return KATAKANA_INPUT_MODE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ShiftKeyModeSwitch>() {
              public ShiftKeyModeSwitch findValueByNumber(int number) {
                return ShiftKeyModeSwitch.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(8);
      }

      private static final ShiftKeyModeSwitch[] VALUES = values();

      public static ShiftKeyModeSwitch valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private ShiftKeyModeSwitch(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.ShiftKeyModeSwitch)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.NumpadCharacterForm}
     */
    public enum NumpadCharacterForm
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      NUMPAD_INPUT_MODE(0, 0),
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      NUMPAD_FULL_WIDTH(1, 1),
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      NUMPAD_HALF_WIDTH(2, 2),
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      NUMPAD_DIRECT_INPUT(3, 3),
      ;

      /**
       * <code>NUMPAD_INPUT_MODE = 0;</code>
       */
      public static final int NUMPAD_INPUT_MODE_VALUE = 0;
      /**
       * <code>NUMPAD_FULL_WIDTH = 1;</code>
       */
      public static final int NUMPAD_FULL_WIDTH_VALUE = 1;
      /**
       * <code>NUMPAD_HALF_WIDTH = 2;</code>
       */
      public static final int NUMPAD_HALF_WIDTH_VALUE = 2;
      /**
       * <code>NUMPAD_DIRECT_INPUT = 3;</code>
       */
      public static final int NUMPAD_DIRECT_INPUT_VALUE = 3;


      public final int getNumber() { return value; }

      public static NumpadCharacterForm valueOf(int value) {
        switch (value) {
          case 0: return NUMPAD_INPUT_MODE;
          case 1: return NUMPAD_FULL_WIDTH;
          case 2: return NUMPAD_HALF_WIDTH;
          case 3: return NUMPAD_DIRECT_INPUT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<NumpadCharacterForm>() {
              public NumpadCharacterForm findValueByNumber(int number) {
                return NumpadCharacterForm.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(9);
      }

      private static final NumpadCharacterForm[] VALUES = values();

      public static NumpadCharacterForm valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private NumpadCharacterForm(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.NumpadCharacterForm)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.AutoConversionKey}
     */
    public enum AutoConversionKey
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      AUTO_CONVERSION_OFF(0, 0),
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      AUTO_CONVERSION_KUTEN(1, 1),
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      AUTO_CONVERSION_TOUTEN(2, 2),
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      AUTO_CONVERSION_QUESTION_MARK(3, 4),
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      AUTO_CONVERSION_EXCLAMATION_MARK(4, 8),
      ;

      /**
       * <code>AUTO_CONVERSION_OFF = 0;</code>
       */
      public static final int AUTO_CONVERSION_OFF_VALUE = 0;
      /**
       * <code>AUTO_CONVERSION_KUTEN = 1;</code>
       */
      public static final int AUTO_CONVERSION_KUTEN_VALUE = 1;
      /**
       * <code>AUTO_CONVERSION_TOUTEN = 2;</code>
       */
      public static final int AUTO_CONVERSION_TOUTEN_VALUE = 2;
      /**
       * <code>AUTO_CONVERSION_QUESTION_MARK = 4;</code>
       */
      public static final int AUTO_CONVERSION_QUESTION_MARK_VALUE = 4;
      /**
       * <code>AUTO_CONVERSION_EXCLAMATION_MARK = 8;</code>
       */
      public static final int AUTO_CONVERSION_EXCLAMATION_MARK_VALUE = 8;


      public final int getNumber() { return value; }

      public static AutoConversionKey valueOf(int value) {
        switch (value) {
          case 0: return AUTO_CONVERSION_OFF;
          case 1: return AUTO_CONVERSION_KUTEN;
          case 2: return AUTO_CONVERSION_TOUTEN;
          case 4: return AUTO_CONVERSION_QUESTION_MARK;
          case 8: return AUTO_CONVERSION_EXCLAMATION_MARK;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AutoConversionKey>() {
              public AutoConversionKey findValueByNumber(int number) {
                return AutoConversionKey.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(10);
      }

      private static final AutoConversionKey[] VALUES = values();

      public static AutoConversionKey valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private AutoConversionKey(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.AutoConversionKey)
    }

    /**
     * Protobuf enum {@code mozc.config.Config.YenSignCharacter}
     *
     * <pre>
     * Mac only config items: yen_sign_character and use_japanese_layout.
     * </pre>
     */
    public enum YenSignCharacter
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>YEN_SIGN = 0;</code>
       */
      YEN_SIGN(0, 0),
      /**
       * <code>BACKSLASH = 1;</code>
       */
      BACKSLASH(1, 1),
      ;

      /**
       * <code>YEN_SIGN = 0;</code>
       */
      public static final int YEN_SIGN_VALUE = 0;
      /**
       * <code>BACKSLASH = 1;</code>
       */
      public static final int BACKSLASH_VALUE = 1;


      public final int getNumber() { return value; }

      public static YenSignCharacter valueOf(int value) {
        switch (value) {
          case 0: return YEN_SIGN;
          case 1: return BACKSLASH;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<YenSignCharacter>() {
              public YenSignCharacter findValueByNumber(int number) {
                return YenSignCharacter.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDescriptor().getEnumTypes().get(11);
      }

      private static final YenSignCharacter[] VALUES = values();

      public static YenSignCharacter valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private YenSignCharacter(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:mozc.config.Config.YenSignCharacter)
    }

    public interface CharacterFormRuleOrBuilder
        extends com.google.protobuf.MessageOrBuilder {

      // optional string group = 1;
      /**
       * <code>optional string group = 1;</code>
       */
      boolean hasGroup();
      /**
       * <code>optional string group = 1;</code>
       */
      java.lang.String getGroup();
      /**
       * <code>optional string group = 1;</code>
       */
      com.google.protobuf.ByteString
          getGroupBytes();

      // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      boolean hasPreeditCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm();

      // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      boolean hasConversionCharacterForm();
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm();
    }
    /**
     * Protobuf type {@code mozc.config.Config.CharacterFormRule}
     */
    public static final class CharacterFormRule extends
        com.google.protobuf.GeneratedMessage
        implements CharacterFormRuleOrBuilder {
      // Use CharacterFormRule.newBuilder() to construct.
      private CharacterFormRule(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
        this.unknownFields = builder.getUnknownFields();
      }
      private CharacterFormRule(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

      private static final CharacterFormRule defaultInstance;
      public static CharacterFormRule getDefaultInstance() {
        return defaultInstance;
      }

      public CharacterFormRule getDefaultInstanceForType() {
        return defaultInstance;
      }

      private final com.google.protobuf.UnknownFieldSet unknownFields;
      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
          getUnknownFields() {
        return this.unknownFields;
      }
      private CharacterFormRule(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        initFields();
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(input, unknownFields,
                                       extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                bitField0_ |= 0x00000001;
                group_ = input.readBytes();
                break;
              }
              case 16: {
                int rawValue = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(rawValue);
                if (value == null) {
                  unknownFields.mergeVarintField(2, rawValue);
                } else {
                  bitField0_ |= 0x00000002;
                  preeditCharacterForm_ = value;
                }
                break;
              }
              case 24: {
                int rawValue = input.readEnum();
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.valueOf(rawValue);
                if (value == null) {
                  unknownFields.mergeVarintField(3, rawValue);
                } else {
                  bitField0_ |= 0x00000004;
                  conversionCharacterForm_ = value;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e.getMessage()).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
      }

      public static com.google.protobuf.Parser<CharacterFormRule> PARSER =
          new com.google.protobuf.AbstractParser<CharacterFormRule>() {
        public CharacterFormRule parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new CharacterFormRule(input, extensionRegistry);
        }
      };

      @java.lang.Override
      public com.google.protobuf.Parser<CharacterFormRule> getParserForType() {
        return PARSER;
      }

      private int bitField0_;
      // optional string group = 1;
      public static final int GROUP_FIELD_NUMBER = 1;
      private java.lang.Object group_;
      /**
       * <code>optional string group = 1;</code>
       */
      public boolean hasGroup() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string group = 1;</code>
       */
      public java.lang.String getGroup() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            group_ = s;
          }
          return s;
        }
      }
      /**
       * <code>optional string group = 1;</code>
       */
      public com.google.protobuf.ByteString
          getGroupBytes() {
        java.lang.Object ref = group_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          group_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
      public static final int PREEDIT_CHARACTER_FORM_FIELD_NUMBER = 2;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm preeditCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      public boolean hasPreeditCharacterForm() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
        return preeditCharacterForm_;
      }

      // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
      public static final int CONVERSION_CHARACTER_FORM_FIELD_NUMBER = 3;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm conversionCharacterForm_;
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      public boolean hasConversionCharacterForm() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
        return conversionCharacterForm_;
      }

      private void initFields() {
        group_ = "";
        preeditCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
        conversionCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
      }
      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized != -1) return isInitialized == 1;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeBytes(1, getGroupBytes());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          output.writeEnum(2, preeditCharacterForm_.getNumber());
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          output.writeEnum(3, conversionCharacterForm_.getNumber());
        }
        getUnknownFields().writeTo(output);
      }

      private int memoizedSerializedSize = -1;
      public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(1, getGroupBytes());
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(2, preeditCharacterForm_.getNumber());
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, conversionCharacterForm_.getNumber());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSerializedSize = size;
        return size;
      }

      private static final long serialVersionUID = 0L;
      @java.lang.Override
      protected java.lang.Object writeReplace()
          throws java.io.ObjectStreamException {
        return super.writeReplace();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return PARSER.parseFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseFrom(input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return PARSER.parseDelimitedFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseDelimitedFrom(input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return PARSER.parseFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseFrom(input, extensionRegistry);
      }

      public static Builder newBuilder() { return Builder.create(); }
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule prototype) {
        return newBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() { return newBuilder(this); }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.CharacterFormRule}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder>
         implements org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          }
        }
        private static Builder create() {
          return new Builder();
        }

        public Builder clear() {
          super.clear();
          group_ = "";
          bitField0_ = (bitField0_ & ~0x00000001);
          preeditCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
          bitField0_ = (bitField0_ & ~0x00000002);
          conversionCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }

        public Builder clone() {
          return create().mergeFrom(buildPartial());
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_CharacterFormRule_descriptor;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance();
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
            to_bitField0_ |= 0x00000001;
          }
          result.group_ = group_;
          if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
            to_bitField0_ |= 0x00000002;
          }
          result.preeditCharacterForm_ = preeditCharacterForm_;
          if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
            to_bitField0_ |= 0x00000004;
          }
          result.conversionCharacterForm_ = conversionCharacterForm_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance()) return this;
          if (other.hasGroup()) {
            bitField0_ |= 0x00000001;
            group_ = other.group_;
            onChanged();
          }
          if (other.hasPreeditCharacterForm()) {
            setPreeditCharacterForm(other.getPreeditCharacterForm());
          }
          if (other.hasConversionCharacterForm()) {
            setConversionCharacterForm(other.getConversionCharacterForm());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule) e.getUnfinishedMessage();
            throw e;
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        // optional string group = 1;
        private java.lang.Object group_ = "";
        /**
         * <code>optional string group = 1;</code>
         */
        public boolean hasGroup() {
          return ((bitField0_ & 0x00000001) == 0x00000001);
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public java.lang.String getGroup() {
          java.lang.Object ref = group_;
          if (!(ref instanceof java.lang.String)) {
            java.lang.String s = ((com.google.protobuf.ByteString) ref)
                .toStringUtf8();
            group_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public com.google.protobuf.ByteString
            getGroupBytes() {
          java.lang.Object ref = group_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            group_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder setGroup(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          group_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder clearGroup() {
          bitField0_ = (bitField0_ & ~0x00000001);
          group_ = getDefaultInstance().getGroup();
          onChanged();
          return this;
        }
        /**
         * <code>optional string group = 1;</code>
         */
        public Builder setGroupBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          group_ = value;
          onChanged();
          return this;
        }

        // optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];
        private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm preeditCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public boolean hasPreeditCharacterForm() {
          return ((bitField0_ & 0x00000002) == 0x00000002);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getPreeditCharacterForm() {
          return preeditCharacterForm_;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public Builder setPreeditCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000002;
          preeditCharacterForm_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm preedit_character_form = 2 [default = FULL_WIDTH];</code>
         */
        public Builder clearPreeditCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000002);
          preeditCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
          onChanged();
          return this;
        }

        // optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];
        private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm conversionCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public boolean hasConversionCharacterForm() {
          return ((bitField0_ & 0x00000004) == 0x00000004);
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm getConversionCharacterForm() {
          return conversionCharacterForm_;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public Builder setConversionCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000004;
          conversionCharacterForm_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional .mozc.config.Config.CharacterForm conversion_character_form = 3 [default = FULL_WIDTH];</code>
         */
        public Builder clearConversionCharacterForm() {
          bitField0_ = (bitField0_ & ~0x00000004);
          conversionCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterForm.FULL_WIDTH;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.config.Config.CharacterFormRule)
      }

      static {
        defaultInstance = new CharacterFormRule(true);
        defaultInstance.initFields();
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.CharacterFormRule)
    }

    public interface InformationListConfigOrBuilder
        extends com.google.protobuf.MessageOrBuilder {

      // optional bool use_local_usage_dictionary = 1 [default = true];
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      boolean hasUseLocalUsageDictionary();
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      boolean getUseLocalUsageDictionary();
    }
    /**
     * Protobuf type {@code mozc.config.Config.InformationListConfig}
     */
    public static final class InformationListConfig extends
        com.google.protobuf.GeneratedMessage
        implements InformationListConfigOrBuilder {
      // Use InformationListConfig.newBuilder() to construct.
      private InformationListConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
        this.unknownFields = builder.getUnknownFields();
      }
      private InformationListConfig(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

      private static final InformationListConfig defaultInstance;
      public static InformationListConfig getDefaultInstance() {
        return defaultInstance;
      }

      public InformationListConfig getDefaultInstanceForType() {
        return defaultInstance;
      }

      private final com.google.protobuf.UnknownFieldSet unknownFields;
      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
          getUnknownFields() {
        return this.unknownFields;
      }
      private InformationListConfig(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        initFields();
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(input, unknownFields,
                                       extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 8: {
                bitField0_ |= 0x00000001;
                useLocalUsageDictionary_ = input.readBool();
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e.getMessage()).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
      }

      public static com.google.protobuf.Parser<InformationListConfig> PARSER =
          new com.google.protobuf.AbstractParser<InformationListConfig>() {
        public InformationListConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new InformationListConfig(input, extensionRegistry);
        }
      };

      @java.lang.Override
      public com.google.protobuf.Parser<InformationListConfig> getParserForType() {
        return PARSER;
      }

      private int bitField0_;
      // optional bool use_local_usage_dictionary = 1 [default = true];
      public static final int USE_LOCAL_USAGE_DICTIONARY_FIELD_NUMBER = 1;
      private boolean useLocalUsageDictionary_;
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      public boolean hasUseLocalUsageDictionary() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
       */
      public boolean getUseLocalUsageDictionary() {
        return useLocalUsageDictionary_;
      }

      private void initFields() {
        useLocalUsageDictionary_ = true;
      }
      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized != -1) return isInitialized == 1;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        getSerializedSize();
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          output.writeBool(1, useLocalUsageDictionary_);
        }
        getUnknownFields().writeTo(output);
      }

      private int memoizedSerializedSize = -1;
      public int getSerializedSize() {
        int size = memoizedSerializedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, useLocalUsageDictionary_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSerializedSize = size;
        return size;
      }

      private static final long serialVersionUID = 0L;
      @java.lang.Override
      protected java.lang.Object writeReplace()
          throws java.io.ObjectStreamException {
        return super.writeReplace();
      }

      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return PARSER.parseFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseFrom(input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return PARSER.parseDelimitedFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseDelimitedFrom(input, extensionRegistry);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return PARSER.parseFrom(input);
      }
      public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return PARSER.parseFrom(input, extensionRegistry);
      }

      public static Builder newBuilder() { return Builder.create(); }
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig prototype) {
        return newBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() { return newBuilder(this); }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code mozc.config.Config.InformationListConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder>
         implements org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder.class);
        }

        // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          }
        }
        private static Builder create() {
          return new Builder();
        }

        public Builder clear() {
          super.clear();
          useLocalUsageDictionary_ = true;
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        public Builder clone() {
          return create().mergeFrom(buildPartial());
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_InformationListConfig_descriptor;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getDefaultInstanceForType() {
          return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig build() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig buildPartial() {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
            to_bitField0_ |= 0x00000001;
          }
          result.useLocalUsageDictionary_ = useLocalUsageDictionary_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) {
            return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig other) {
          if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) return this;
          if (other.hasUseLocalUsageDictionary()) {
            setUseLocalUsageDictionary(other.getUseLocalUsageDictionary());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig) e.getUnfinishedMessage();
            throw e;
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        // optional bool use_local_usage_dictionary = 1 [default = true];
        private boolean useLocalUsageDictionary_ = true;
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public boolean hasUseLocalUsageDictionary() {
          return ((bitField0_ & 0x00000001) == 0x00000001);
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public boolean getUseLocalUsageDictionary() {
          return useLocalUsageDictionary_;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public Builder setUseLocalUsageDictionary(boolean value) {
          bitField0_ |= 0x00000001;
          useLocalUsageDictionary_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional bool use_local_usage_dictionary = 1 [default = true];</code>
         */
        public Builder clearUseLocalUsageDictionary() {
          bitField0_ = (bitField0_ & ~0x00000001);
          useLocalUsageDictionary_ = true;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:mozc.config.Config.InformationListConfig)
      }

      static {
        defaultInstance = new InformationListConfig(true);
        defaultInstance.initFields();
      }

      // @@protoc_insertion_point(class_scope:mozc.config.Config.InformationListConfig)
    }

    private int bitField0_;
    private int bitField1_;
    // optional .mozc.config.GeneralConfig general_config = 1;
    public static final int GENERAL_CONFIG_FIELD_NUMBER = 1;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_;
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    public boolean hasGeneralConfig() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
      return generalConfig_;
    }
    /**
     * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
     *
     * <pre>
     * General config and logging/debugging:
     * We won't use 2-9 and 20-39 ids anymore for historical reasons.
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
      return generalConfig_;
    }

    // optional int32 verbose_level = 10 [default = 0];
    public static final int VERBOSE_LEVEL_FIELD_NUMBER = 10;
    private int verboseLevel_;
    /**
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     *
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     */
    public boolean hasVerboseLevel() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional int32 verbose_level = 10 [default = 0];</code>
     *
     * <pre>
     * set verbose level of logging library (FLAGS_v)
     * </pre>
     */
    public int getVerboseLevel() {
      return verboseLevel_;
    }

    // optional bool DEPRECATED_log_all_commands = 11 [default = false];
    public static final int DEPRECATED_LOG_ALL_COMMANDS_FIELD_NUMBER = 11;
    private boolean dEPRECATEDLogAllCommands_;
    /**
     * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
     *
     * <pre>
     * This flag is not used
     * </pre>
     */
    public boolean hasDEPRECATEDLogAllCommands() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
     *
     * <pre>
     * This flag is not used
     * </pre>
     */
    public boolean getDEPRECATEDLogAllCommands() {
      return dEPRECATEDLogAllCommands_;
    }

    // optional bool incognito_mode = 20 [default = false];
    public static final int INCOGNITO_MODE_FIELD_NUMBER = 20;
    private boolean incognitoMode_;
    /**
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     *
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     */
    public boolean hasIncognitoMode() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional bool incognito_mode = 20 [default = false];</code>
     *
     * <pre>
     * Incognito mode:
     * Disable all mutable operation if incognito_mode is true
     * </pre>
     */
    public boolean getIncognitoMode() {
      return incognitoMode_;
    }

    // optional bool check_default = 22 [default = true];
    public static final int CHECK_DEFAULT_FIELD_NUMBER = 22;
    private boolean checkDefault_;
    /**
     * <code>optional bool check_default = 22 [default = true];</code>
     *
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     */
    public boolean hasCheckDefault() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional bool check_default = 22 [default = true];</code>
     *
     * <pre>
     * whether to show the set default dialog on startup
     * </pre>
     */
    public boolean getCheckDefault() {
      return checkDefault_;
    }

    // optional bool presentation_mode = 23 [default = false];
    public static final int PRESENTATION_MODE_FIELD_NUMBER = 23;
    private boolean presentationMode_;
    /**
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     *
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     */
    public boolean hasPresentationMode() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional bool presentation_mode = 23 [default = false];</code>
     *
     * <pre>
     * Presentation mode:
     * disable all suggestion temporally.
     * </pre>
     */
    public boolean getPresentationMode() {
      return presentationMode_;
    }

    // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
    public static final int PREEDIT_METHOD_FIELD_NUMBER = 40;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod preeditMethod_;
    /**
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     *
     * <pre>
     * Roman/Kana
     * </pre>
     */
    public boolean hasPreeditMethod() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
     *
     * <pre>
     * Roman/Kana
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
      return preeditMethod_;
    }

    // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
    public static final int SESSION_KEYMAP_FIELD_NUMBER = 41;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap sessionKeymap_;
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    public boolean hasSessionKeymap() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
      return sessionKeymap_;
    }

    // optional bytes custom_keymap_table = 42;
    public static final int CUSTOM_KEYMAP_TABLE_FIELD_NUMBER = 42;
    private com.google.protobuf.ByteString customKeymapTable_;
    /**
     * <code>optional bytes custom_keymap_table = 42;</code>
     *
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     */
    public boolean hasCustomKeymapTable() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional bytes custom_keymap_table = 42;</code>
     *
     * <pre>
     * custom keymap
     * TODO(taku): replace it with repeated field
     * </pre>
     */
    public com.google.protobuf.ByteString getCustomKeymapTable() {
      return customKeymapTable_;
    }

    // optional bytes custom_roman_table = 43;
    public static final int CUSTOM_ROMAN_TABLE_FIELD_NUMBER = 43;
    private com.google.protobuf.ByteString customRomanTable_;
    /**
     * <code>optional bytes custom_roman_table = 43;</code>
     *
     * <pre>
     * custom roman table
     * </pre>
     */
    public boolean hasCustomRomanTable() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional bytes custom_roman_table = 43;</code>
     *
     * <pre>
     * custom roman table
     * </pre>
     */
    public com.google.protobuf.ByteString getCustomRomanTable() {
      return customRomanTable_;
    }

    // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
    public static final int PUNCTUATION_METHOD_FIELD_NUMBER = 45;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod punctuationMethod_;
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    public boolean hasPunctuationMethod() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
      return punctuationMethod_;
    }

    // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
    public static final int SYMBOL_METHOD_FIELD_NUMBER = 46;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod symbolMethod_;
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    public boolean hasSymbolMethod() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
      return symbolMethod_;
    }

    // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
    public static final int SPACE_CHARACTER_FORM_FIELD_NUMBER = 47;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm spaceCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    public boolean hasSpaceCharacterForm() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
      return spaceCharacterForm_;
    }

    // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
    public static final int USE_KEYBOARD_TO_CHANGE_PREEDIT_METHOD_FIELD_NUMBER = 48;
    private boolean useKeyboardToChangePreeditMethod_;
    /**
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     *
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     *
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     */
    public boolean hasUseKeyboardToChangePreeditMethod() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
     *
     * <pre>
     * If this flag is true, Mozc toggles preedit method with some predefined
     * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
     * key events so that their preferred can be preserved even when the toggle
     * key is pressed by accident.
     * As for Mozc, only Windows client supports such kind of toggle so this flag
     * is currently valid only on Windows.
     *
     * Background:
     *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
     *   keyboard to toggle the preedit method between Roman and Kana style and
     *   this behavior was finally adopted into JIS X 4064:2002 as a basic
     *   functionality which is expected to support by a Japanese Input Method.
     *   However, people who are not aware of this functionality have been
     *   puzzled because the default key stroke is likely to be pressed
     *   by accident.
     * </pre>
     */
    public boolean getUseKeyboardToChangePreeditMethod() {
      return useKeyboardToChangePreeditMethod_;
    }

    // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
    public static final int HISTORY_LEARNING_LEVEL_FIELD_NUMBER = 50;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel historyLearningLevel_;
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    public boolean hasHistoryLearningLevel() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
      return historyLearningLevel_;
    }

    // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
    public static final int SELECTION_SHORTCUT_FIELD_NUMBER = 52;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut selectionShortcut_;
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    public boolean hasSelectionShortcut() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
      return selectionShortcut_;
    }

    // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
    public static final int CHARACTER_FORM_RULES_FIELD_NUMBER = 54;
    private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_;
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
        getCharacterFormRulesOrBuilderList() {
      return characterFormRules_;
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public int getCharacterFormRulesCount() {
      return characterFormRules_.size();
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
      return characterFormRules_.get(index);
    }
    /**
     * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
        int index) {
      return characterFormRules_.get(index);
    }

    // optional bool use_auto_ime_turn_off = 56 [default = true];
    public static final int USE_AUTO_IME_TURN_OFF_FIELD_NUMBER = 56;
    private boolean useAutoImeTurnOff_;
    /**
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     *
     * <pre>
     * auto IME turn off feature
     * </pre>
     */
    public boolean hasUseAutoImeTurnOff() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
     *
     * <pre>
     * auto IME turn off feature
     * </pre>
     */
    public boolean getUseAutoImeTurnOff() {
      return useAutoImeTurnOff_;
    }

    // optional bool use_cascading_window = 58 [default = true];
    public static final int USE_CASCADING_WINDOW_FIELD_NUMBER = 58;
    private boolean useCascadingWindow_;
    /**
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     *
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     */
    public boolean hasUseCascadingWindow() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional bool use_cascading_window = 58 [default = true];</code>
     *
     * <pre>
     * Toggle to use cascanding window for debuging.
     * </pre>
     */
    public boolean getUseCascadingWindow() {
      return useCascadingWindow_;
    }

    // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
    public static final int SHIFT_KEY_MODE_SWITCH_FIELD_NUMBER = 59;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch shiftKeyModeSwitch_;
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    public boolean hasShiftKeyModeSwitch() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
      return shiftKeyModeSwitch_;
    }

    // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
    public static final int NUMPAD_CHARACTER_FORM_FIELD_NUMBER = 60;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm numpadCharacterForm_;
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    public boolean hasNumpadCharacterForm() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
      return numpadCharacterForm_;
    }

    // optional bool use_auto_conversion = 61 [default = false];
    public static final int USE_AUTO_CONVERSION_FIELD_NUMBER = 61;
    private boolean useAutoConversion_;
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    public boolean hasUseAutoConversion() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <code>optional bool use_auto_conversion = 61 [default = false];</code>
     */
    public boolean getUseAutoConversion() {
      return useAutoConversion_;
    }

    // optional uint32 auto_conversion_key = 62 [default = 13];
    public static final int AUTO_CONVERSION_KEY_FIELD_NUMBER = 62;
    private int autoConversionKey_;
    /**
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     *
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     */
    public boolean hasAutoConversionKey() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
     *
     * <pre>
     * can't use AutoConversionKey as a type since
     * undefined enum type is not correctly handled.
     * </pre>
     */
    public int getAutoConversionKey() {
      return autoConversionKey_;
    }

    // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
    public static final int YEN_SIGN_CHARACTER_FIELD_NUMBER = 63;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter yenSignCharacter_;
    /**
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     *
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     */
    public boolean hasYenSignCharacter() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
     *
     * <pre>
     * Mac-original JIS key layout has "yen-sign" key which generates
     * U+00A5 instead of U+005C and sometimes users get troubles with
     * them because they expect backslashes which are rendered as
     * yen-sign.  If this configuration is BACKSLASH, Mozc will
     * interpret U+005C even when the original key event is U+00A5.
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
      return yenSignCharacter_;
    }

    // optional bool use_japanese_layout = 64 [default = false];
    public static final int USE_JAPANESE_LAYOUT_FIELD_NUMBER = 64;
    private boolean useJapaneseLayout_;
    /**
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     *
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     */
    public boolean hasUseJapaneseLayout() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <code>optional bool use_japanese_layout = 64 [default = false];</code>
     *
     * <pre>
     * Use Japanese keyboard layout even when the user uses other
     * keyboard layouts.  In Mac OSX people can use several keyboard
     * layouts such like French or Spanish but some people want to use
     * Japanese layout for Japanese.  See http://b/2917320
     * </pre>
     */
    public boolean getUseJapaneseLayout() {
      return useJapaneseLayout_;
    }

    // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
    public static final int USE_KANA_MODIFIER_INSENSITIVE_CONVERSION_FIELD_NUMBER = 65;
    private boolean useKanaModifierInsensitiveConversion_;
    /**
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     *
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     */
    public boolean hasUseKanaModifierInsensitiveConversion() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
     *
     * <pre>
     * Use kana modifier insensitive conversion.
     * e.g.  -&gt; 
     * Note that Request message has the same field.
     * - Request's one is controlled by the client. A user cannot control it.
     *   On the other hand Config's is under a user's control.
     * - Whether the feature is activated or not is decided by logical-AND
     *   of Request's and Config's.
     * </pre>
     */
    public boolean getUseKanaModifierInsensitiveConversion() {
      return useKanaModifierInsensitiveConversion_;
    }

    // optional bool use_typing_correction = 66 [default = false];
    public static final int USE_TYPING_CORRECTION_FIELD_NUMBER = 66;
    private boolean useTypingCorrection_;
    /**
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     *
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     */
    public boolean hasUseTypingCorrection() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <code>optional bool use_typing_correction = 66 [default = false];</code>
     *
     * <pre>
     * Use typing correction feature.
     * e.g. sunkai -&gt; 
     * </pre>
     */
    public boolean getUseTypingCorrection() {
      return useTypingCorrection_;
    }

    // optional bool use_date_conversion = 80 [default = true];
    public static final int USE_DATE_CONVERSION_FIELD_NUMBER = 80;
    private boolean useDateConversion_;
    /**
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Dictionary (80-99)
     * </pre>
     */
    public boolean hasUseDateConversion() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional bool use_date_conversion = 80 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Dictionary (80-99)
     * </pre>
     */
    public boolean getUseDateConversion() {
      return useDateConversion_;
    }

    // optional bool use_single_kanji_conversion = 81 [default = true];
    public static final int USE_SINGLE_KANJI_CONVERSION_FIELD_NUMBER = 81;
    private boolean useSingleKanjiConversion_;
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    public boolean hasUseSingleKanjiConversion() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
     */
    public boolean getUseSingleKanjiConversion() {
      return useSingleKanjiConversion_;
    }

    // optional bool use_symbol_conversion = 82 [default = true];
    public static final int USE_SYMBOL_CONVERSION_FIELD_NUMBER = 82;
    private boolean useSymbolConversion_;
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    public boolean hasUseSymbolConversion() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
     */
    public boolean getUseSymbolConversion() {
      return useSymbolConversion_;
    }

    // optional bool use_number_conversion = 83 [default = true];
    public static final int USE_NUMBER_CONVERSION_FIELD_NUMBER = 83;
    private boolean useNumberConversion_;
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    public boolean hasUseNumberConversion() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <code>optional bool use_number_conversion = 83 [default = true];</code>
     */
    public boolean getUseNumberConversion() {
      return useNumberConversion_;
    }

    // optional bool use_emoticon_conversion = 84 [default = true];
    public static final int USE_EMOTICON_CONVERSION_FIELD_NUMBER = 84;
    private boolean useEmoticonConversion_;
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    public boolean hasUseEmoticonConversion() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
     */
    public boolean getUseEmoticonConversion() {
      return useEmoticonConversion_;
    }

    // optional bool use_calculator = 85 [default = true];
    public static final int USE_CALCULATOR_FIELD_NUMBER = 85;
    private boolean useCalculator_;
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    public boolean hasUseCalculator() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <code>optional bool use_calculator = 85 [default = true];</code>
     */
    public boolean getUseCalculator() {
      return useCalculator_;
    }

    // optional bool use_t13n_conversion = 86 [default = true];
    public static final int USE_T13N_CONVERSION_FIELD_NUMBER = 86;
    private boolean useT13NConversion_;
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    public boolean hasUseT13NConversion() {
      return ((bitField1_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
     */
    public boolean getUseT13NConversion() {
      return useT13NConversion_;
    }

    // optional bool use_zip_code_conversion = 87 [default = true];
    public static final int USE_ZIP_CODE_CONVERSION_FIELD_NUMBER = 87;
    private boolean useZipCodeConversion_;
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    public boolean hasUseZipCodeConversion() {
      return ((bitField1_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
     */
    public boolean getUseZipCodeConversion() {
      return useZipCodeConversion_;
    }

    // optional bool use_spelling_correction = 88 [default = true];
    public static final int USE_SPELLING_CORRECTION_FIELD_NUMBER = 88;
    private boolean useSpellingCorrection_;
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    public boolean hasUseSpellingCorrection() {
      return ((bitField1_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional bool use_spelling_correction = 88 [default = true];</code>
     */
    public boolean getUseSpellingCorrection() {
      return useSpellingCorrection_;
    }

    // optional bool use_emoji_conversion = 89 [default = false];
    public static final int USE_EMOJI_CONVERSION_FIELD_NUMBER = 89;
    private boolean useEmojiConversion_;
    /**
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    public boolean hasUseEmojiConversion() {
      return ((bitField1_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
     */
    public boolean getUseEmojiConversion() {
      return useEmojiConversion_;
    }

    // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
    public static final int INFORMATION_LIST_CONFIG_FIELD_NUMBER = 90;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_;
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public boolean hasInformationListConfig() {
      return ((bitField1_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
      return informationListConfig_;
    }
    /**
     * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
      return informationListConfig_;
    }

    // optional bool use_history_suggest = 100 [default = true];
    public static final int USE_HISTORY_SUGGEST_FIELD_NUMBER = 100;
    private boolean useHistorySuggest_;
    /**
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Suggest (100-119)
     *
     * Use history-based suggest feature.
     * </pre>
     */
    public boolean hasUseHistorySuggest() {
      return ((bitField1_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional bool use_history_suggest = 100 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Suggest (100-119)
     *
     * Use history-based suggest feature.
     * </pre>
     */
    public boolean getUseHistorySuggest() {
      return useHistorySuggest_;
    }

    // optional bool use_dictionary_suggest = 101 [default = true];
    public static final int USE_DICTIONARY_SUGGEST_FIELD_NUMBER = 101;
    private boolean useDictionarySuggest_;
    /**
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     *
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     */
    public boolean hasUseDictionarySuggest() {
      return ((bitField1_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
     *
     * <pre>
     * Use dictionary-based suggest feature.
     * </pre>
     */
    public boolean getUseDictionarySuggest() {
      return useDictionarySuggest_;
    }

    // optional bool use_realtime_conversion = 102 [default = true];
    public static final int USE_REALTIME_CONVERSION_FIELD_NUMBER = 102;
    private boolean useRealtimeConversion_;
    /**
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     *
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     */
    public boolean hasUseRealtimeConversion() {
      return ((bitField1_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
     *
     * <pre>
     * Use realtime conversion feature.
     * </pre>
     */
    public boolean getUseRealtimeConversion() {
      return useRealtimeConversion_;
    }

    // optional uint32 suggestions_size = 110 [default = 3];
    public static final int SUGGESTIONS_SIZE_FIELD_NUMBER = 110;
    private int suggestionsSize_;
    /**
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     *
     * <pre>
     * Size of suggestions.
     * </pre>
     */
    public boolean hasSuggestionsSize() {
      return ((bitField1_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
     *
     * <pre>
     * Size of suggestions.
     * </pre>
     */
    public int getSuggestionsSize() {
      return suggestionsSize_;
    }

    // optional bool use_mode_indicator = 120 [default = true];
    public static final int USE_MODE_INDICATOR_FIELD_NUMBER = 120;
    private boolean useModeIndicator_;
    /**
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Renderer (120-139)
     *
     * Use mode indicator feature.
     * </pre>
     */
    public boolean hasUseModeIndicator() {
      return ((bitField1_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional bool use_mode_indicator = 120 [default = true];</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Renderer (120-139)
     *
     * Use mode indicator feature.
     * </pre>
     */
    public boolean getUseModeIndicator() {
      return useModeIndicator_;
    }

    // optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;
    public static final int OBSOLETE_SYNC_CONFIG_FIELD_NUMBER = 300;
    private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig oBSOLETESyncConfig_;
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    public boolean hasOBSOLETESyncConfig() {
      return ((bitField1_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig getOBSOLETESyncConfig() {
      return oBSOLETESyncConfig_;
    }
    /**
     * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
     *
     * <pre>
     *&#47;///////////////////////////////////////////////////////////
     *
     * Cloud (300-319)
     *
     * Configuration for cloud sync feature. This field is obsolete.
     * </pre>
     */
    public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder getOBSOLETESyncConfigOrBuilder() {
      return oBSOLETESyncConfig_;
    }

    // optional bool allow_cloud_handwriting = 301 [default = false];
    public static final int ALLOW_CLOUD_HANDWRITING_FIELD_NUMBER = 301;
    private boolean allowCloudHandwriting_;
    /**
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     *
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     */
    public boolean hasAllowCloudHandwriting() {
      return ((bitField1_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
     *
     * <pre>
     * Allow the cloud handwriting.  The handwriting UI has to notice
     * user before activating the feature, and set this field to true
     * when the user permit.
     * NOTE: OSS version does not handle this field.
     * </pre>
     */
    public boolean getAllowCloudHandwriting() {
      return allowCloudHandwriting_;
    }

    private void initFields() {
      generalConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
      verboseLevel_ = 0;
      dEPRECATEDLogAllCommands_ = false;
      incognitoMode_ = false;
      checkDefault_ = true;
      presentationMode_ = false;
      preeditMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN;
      sessionKeymap_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE;
      customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      punctuationMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN;
      symbolMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT;
      spaceCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE;
      useKeyboardToChangePreeditMethod_ = false;
      historyLearningLevel_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY;
      selectionShortcut_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789;
      characterFormRules_ = java.util.Collections.emptyList();
      useAutoImeTurnOff_ = true;
      useCascadingWindow_ = true;
      shiftKeyModeSwitch_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE;
      numpadCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH;
      useAutoConversion_ = false;
      autoConversionKey_ = 13;
      yenSignCharacter_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN;
      useJapaneseLayout_ = false;
      useKanaModifierInsensitiveConversion_ = false;
      useTypingCorrection_ = false;
      useDateConversion_ = true;
      useSingleKanjiConversion_ = true;
      useSymbolConversion_ = true;
      useNumberConversion_ = true;
      useEmoticonConversion_ = true;
      useCalculator_ = true;
      useT13NConversion_ = true;
      useZipCodeConversion_ = true;
      useSpellingCorrection_ = true;
      useEmojiConversion_ = false;
      informationListConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
      useHistorySuggest_ = true;
      useDictionarySuggest_ = true;
      useRealtimeConversion_ = true;
      suggestionsSize_ = 3;
      useModeIndicator_ = true;
      oBSOLETESyncConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance();
      allowCloudHandwriting_ = false;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized != -1) return isInitialized == 1;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, generalConfig_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBool(11, dEPRECATEDLogAllCommands_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeBool(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeEnum(40, preeditMethod_.getNumber());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeEnum(41, sessionKeymap_.getNumber());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeBytes(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeBytes(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeEnum(45, punctuationMethod_.getNumber());
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeEnum(46, symbolMethod_.getNumber());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeEnum(47, spaceCharacterForm_.getNumber());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeBool(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeEnum(50, historyLearningLevel_.getNumber());
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeEnum(52, selectionShortcut_.getNumber());
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        output.writeMessage(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeBool(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeBool(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeEnum(59, shiftKeyModeSwitch_.getNumber());
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeEnum(60, numpadCharacterForm_.getNumber());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeBool(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeUInt32(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeEnum(63, yenSignCharacter_.getNumber());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeBool(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeBool(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeBool(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeBool(80, useDateConversion_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeBool(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeBool(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeBool(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeBool(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeBool(85, useCalculator_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        output.writeBool(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        output.writeBool(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        output.writeBool(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        output.writeBool(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(90, informationListConfig_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        output.writeBool(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        output.writeBool(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        output.writeBool(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        output.writeUInt32(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        output.writeBool(120, useModeIndicator_);
      }
      if (((bitField1_ & 0x00000400) == 0x00000400)) {
        output.writeMessage(300, oBSOLETESyncConfig_);
      }
      if (((bitField1_ & 0x00000800) == 0x00000800)) {
        output.writeBool(301, allowCloudHandwriting_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, generalConfig_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, verboseLevel_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, dEPRECATEDLogAllCommands_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(20, incognitoMode_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, checkDefault_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, presentationMode_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(40, preeditMethod_.getNumber());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(41, sessionKeymap_.getNumber());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(42, customKeymapTable_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(43, customRomanTable_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(45, punctuationMethod_.getNumber());
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(46, symbolMethod_.getNumber());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(47, spaceCharacterForm_.getNumber());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(48, useKeyboardToChangePreeditMethod_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(50, historyLearningLevel_.getNumber());
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(52, selectionShortcut_.getNumber());
      }
      for (int i = 0; i < characterFormRules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(54, characterFormRules_.get(i));
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(56, useAutoImeTurnOff_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(58, useCascadingWindow_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(59, shiftKeyModeSwitch_.getNumber());
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(60, numpadCharacterForm_.getNumber());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(61, useAutoConversion_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(62, autoConversionKey_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(63, yenSignCharacter_.getNumber());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(64, useJapaneseLayout_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(65, useKanaModifierInsensitiveConversion_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(66, useTypingCorrection_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(80, useDateConversion_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(81, useSingleKanjiConversion_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(82, useSymbolConversion_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(83, useNumberConversion_);
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(84, useEmoticonConversion_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(85, useCalculator_);
      }
      if (((bitField1_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(86, useT13NConversion_);
      }
      if (((bitField1_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(87, useZipCodeConversion_);
      }
      if (((bitField1_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(88, useSpellingCorrection_);
      }
      if (((bitField1_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(89, useEmojiConversion_);
      }
      if (((bitField1_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(90, informationListConfig_);
      }
      if (((bitField1_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(100, useHistorySuggest_);
      }
      if (((bitField1_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(101, useDictionarySuggest_);
      }
      if (((bitField1_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(102, useRealtimeConversion_);
      }
      if (((bitField1_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(110, suggestionsSize_);
      }
      if (((bitField1_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(120, useModeIndicator_);
      }
      if (((bitField1_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(300, oBSOLETESyncConfig_);
      }
      if (((bitField1_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(301, allowCloudHandwriting_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code mozc.config.Config}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder>
       implements org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.ConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.class, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.Builder.class);
      }

      // Construct using org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getGeneralConfigFieldBuilder();
          getCharacterFormRulesFieldBuilder();
          getInformationListConfigFieldBuilder();
          getOBSOLETESyncConfigFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        if (generalConfigBuilder_ == null) {
          generalConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
        } else {
          generalConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        verboseLevel_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        dEPRECATEDLogAllCommands_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        incognitoMode_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        checkDefault_ = true;
        bitField0_ = (bitField0_ & ~0x00000010);
        presentationMode_ = false;
        bitField0_ = (bitField0_ & ~0x00000020);
        preeditMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN;
        bitField0_ = (bitField0_ & ~0x00000040);
        sessionKeymap_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE;
        bitField0_ = (bitField0_ & ~0x00000080);
        customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000200);
        punctuationMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN;
        bitField0_ = (bitField0_ & ~0x00000400);
        symbolMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT;
        bitField0_ = (bitField0_ & ~0x00000800);
        spaceCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE;
        bitField0_ = (bitField0_ & ~0x00001000);
        useKeyboardToChangePreeditMethod_ = false;
        bitField0_ = (bitField0_ & ~0x00002000);
        historyLearningLevel_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY;
        bitField0_ = (bitField0_ & ~0x00004000);
        selectionShortcut_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789;
        bitField0_ = (bitField0_ & ~0x00008000);
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00010000);
        } else {
          characterFormRulesBuilder_.clear();
        }
        useAutoImeTurnOff_ = true;
        bitField0_ = (bitField0_ & ~0x00020000);
        useCascadingWindow_ = true;
        bitField0_ = (bitField0_ & ~0x00040000);
        shiftKeyModeSwitch_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE;
        bitField0_ = (bitField0_ & ~0x00080000);
        numpadCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH;
        bitField0_ = (bitField0_ & ~0x00100000);
        useAutoConversion_ = false;
        bitField0_ = (bitField0_ & ~0x00200000);
        autoConversionKey_ = 13;
        bitField0_ = (bitField0_ & ~0x00400000);
        yenSignCharacter_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN;
        bitField0_ = (bitField0_ & ~0x00800000);
        useJapaneseLayout_ = false;
        bitField0_ = (bitField0_ & ~0x01000000);
        useKanaModifierInsensitiveConversion_ = false;
        bitField0_ = (bitField0_ & ~0x02000000);
        useTypingCorrection_ = false;
        bitField0_ = (bitField0_ & ~0x04000000);
        useDateConversion_ = true;
        bitField0_ = (bitField0_ & ~0x08000000);
        useSingleKanjiConversion_ = true;
        bitField0_ = (bitField0_ & ~0x10000000);
        useSymbolConversion_ = true;
        bitField0_ = (bitField0_ & ~0x20000000);
        useNumberConversion_ = true;
        bitField0_ = (bitField0_ & ~0x40000000);
        useEmoticonConversion_ = true;
        bitField0_ = (bitField0_ & ~0x80000000);
        useCalculator_ = true;
        bitField1_ = (bitField1_ & ~0x00000001);
        useT13NConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000002);
        useZipCodeConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000004);
        useSpellingCorrection_ = true;
        bitField1_ = (bitField1_ & ~0x00000008);
        useEmojiConversion_ = false;
        bitField1_ = (bitField1_ & ~0x00000010);
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
        } else {
          informationListConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000020);
        useHistorySuggest_ = true;
        bitField1_ = (bitField1_ & ~0x00000040);
        useDictionarySuggest_ = true;
        bitField1_ = (bitField1_ & ~0x00000080);
        useRealtimeConversion_ = true;
        bitField1_ = (bitField1_ & ~0x00000100);
        suggestionsSize_ = 3;
        bitField1_ = (bitField1_ & ~0x00000200);
        useModeIndicator_ = true;
        bitField1_ = (bitField1_ & ~0x00000400);
        if (oBSOLETESyncConfigBuilder_ == null) {
          oBSOLETESyncConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance();
        } else {
          oBSOLETESyncConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000800);
        allowCloudHandwriting_ = false;
        bitField1_ = (bitField1_ & ~0x00001000);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.internal_static_mozc_config_Config_descriptor;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config getDefaultInstanceForType() {
        return org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance();
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config build() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config buildPartial() {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config result = new org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (generalConfigBuilder_ == null) {
          result.generalConfig_ = generalConfig_;
        } else {
          result.generalConfig_ = generalConfigBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.verboseLevel_ = verboseLevel_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.dEPRECATEDLogAllCommands_ = dEPRECATEDLogAllCommands_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.incognitoMode_ = incognitoMode_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.checkDefault_ = checkDefault_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.presentationMode_ = presentationMode_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.preeditMethod_ = preeditMethod_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.sessionKeymap_ = sessionKeymap_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.customKeymapTable_ = customKeymapTable_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.customRomanTable_ = customRomanTable_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.punctuationMethod_ = punctuationMethod_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.symbolMethod_ = symbolMethod_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.spaceCharacterForm_ = spaceCharacterForm_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.useKeyboardToChangePreeditMethod_ = useKeyboardToChangePreeditMethod_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.historyLearningLevel_ = historyLearningLevel_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.selectionShortcut_ = selectionShortcut_;
        if (characterFormRulesBuilder_ == null) {
          if (((bitField0_ & 0x00010000) == 0x00010000)) {
            characterFormRules_ = java.util.Collections.unmodifiableList(characterFormRules_);
            bitField0_ = (bitField0_ & ~0x00010000);
          }
          result.characterFormRules_ = characterFormRules_;
        } else {
          result.characterFormRules_ = characterFormRulesBuilder_.build();
        }
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.useAutoImeTurnOff_ = useAutoImeTurnOff_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.useCascadingWindow_ = useCascadingWindow_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.shiftKeyModeSwitch_ = shiftKeyModeSwitch_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.numpadCharacterForm_ = numpadCharacterForm_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.useAutoConversion_ = useAutoConversion_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.autoConversionKey_ = autoConversionKey_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.yenSignCharacter_ = yenSignCharacter_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.useJapaneseLayout_ = useJapaneseLayout_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.useKanaModifierInsensitiveConversion_ = useKanaModifierInsensitiveConversion_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.useTypingCorrection_ = useTypingCorrection_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.useDateConversion_ = useDateConversion_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.useSingleKanjiConversion_ = useSingleKanjiConversion_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.useSymbolConversion_ = useSymbolConversion_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.useNumberConversion_ = useNumberConversion_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x40000000;
        }
        result.useEmoticonConversion_ = useEmoticonConversion_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x80000000;
        }
        result.useCalculator_ = useCalculator_;
        if (((from_bitField1_ & 0x00000002) == 0x00000002)) {
          to_bitField1_ |= 0x00000001;
        }
        result.useT13NConversion_ = useT13NConversion_;
        if (((from_bitField1_ & 0x00000004) == 0x00000004)) {
          to_bitField1_ |= 0x00000002;
        }
        result.useZipCodeConversion_ = useZipCodeConversion_;
        if (((from_bitField1_ & 0x00000008) == 0x00000008)) {
          to_bitField1_ |= 0x00000004;
        }
        result.useSpellingCorrection_ = useSpellingCorrection_;
        if (((from_bitField1_ & 0x00000010) == 0x00000010)) {
          to_bitField1_ |= 0x00000008;
        }
        result.useEmojiConversion_ = useEmojiConversion_;
        if (((from_bitField1_ & 0x00000020) == 0x00000020)) {
          to_bitField1_ |= 0x00000010;
        }
        if (informationListConfigBuilder_ == null) {
          result.informationListConfig_ = informationListConfig_;
        } else {
          result.informationListConfig_ = informationListConfigBuilder_.build();
        }
        if (((from_bitField1_ & 0x00000040) == 0x00000040)) {
          to_bitField1_ |= 0x00000020;
        }
        result.useHistorySuggest_ = useHistorySuggest_;
        if (((from_bitField1_ & 0x00000080) == 0x00000080)) {
          to_bitField1_ |= 0x00000040;
        }
        result.useDictionarySuggest_ = useDictionarySuggest_;
        if (((from_bitField1_ & 0x00000100) == 0x00000100)) {
          to_bitField1_ |= 0x00000080;
        }
        result.useRealtimeConversion_ = useRealtimeConversion_;
        if (((from_bitField1_ & 0x00000200) == 0x00000200)) {
          to_bitField1_ |= 0x00000100;
        }
        result.suggestionsSize_ = suggestionsSize_;
        if (((from_bitField1_ & 0x00000400) == 0x00000400)) {
          to_bitField1_ |= 0x00000200;
        }
        result.useModeIndicator_ = useModeIndicator_;
        if (((from_bitField1_ & 0x00000800) == 0x00000800)) {
          to_bitField1_ |= 0x00000400;
        }
        if (oBSOLETESyncConfigBuilder_ == null) {
          result.oBSOLETESyncConfig_ = oBSOLETESyncConfig_;
        } else {
          result.oBSOLETESyncConfig_ = oBSOLETESyncConfigBuilder_.build();
        }
        if (((from_bitField1_ & 0x00001000) == 0x00001000)) {
          to_bitField1_ |= 0x00000800;
        }
        result.allowCloudHandwriting_ = allowCloudHandwriting_;
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) {
          return mergeFrom((org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config other) {
        if (other == org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.getDefaultInstance()) return this;
        if (other.hasGeneralConfig()) {
          mergeGeneralConfig(other.getGeneralConfig());
        }
        if (other.hasVerboseLevel()) {
          setVerboseLevel(other.getVerboseLevel());
        }
        if (other.hasDEPRECATEDLogAllCommands()) {
          setDEPRECATEDLogAllCommands(other.getDEPRECATEDLogAllCommands());
        }
        if (other.hasIncognitoMode()) {
          setIncognitoMode(other.getIncognitoMode());
        }
        if (other.hasCheckDefault()) {
          setCheckDefault(other.getCheckDefault());
        }
        if (other.hasPresentationMode()) {
          setPresentationMode(other.getPresentationMode());
        }
        if (other.hasPreeditMethod()) {
          setPreeditMethod(other.getPreeditMethod());
        }
        if (other.hasSessionKeymap()) {
          setSessionKeymap(other.getSessionKeymap());
        }
        if (other.hasCustomKeymapTable()) {
          setCustomKeymapTable(other.getCustomKeymapTable());
        }
        if (other.hasCustomRomanTable()) {
          setCustomRomanTable(other.getCustomRomanTable());
        }
        if (other.hasPunctuationMethod()) {
          setPunctuationMethod(other.getPunctuationMethod());
        }
        if (other.hasSymbolMethod()) {
          setSymbolMethod(other.getSymbolMethod());
        }
        if (other.hasSpaceCharacterForm()) {
          setSpaceCharacterForm(other.getSpaceCharacterForm());
        }
        if (other.hasUseKeyboardToChangePreeditMethod()) {
          setUseKeyboardToChangePreeditMethod(other.getUseKeyboardToChangePreeditMethod());
        }
        if (other.hasHistoryLearningLevel()) {
          setHistoryLearningLevel(other.getHistoryLearningLevel());
        }
        if (other.hasSelectionShortcut()) {
          setSelectionShortcut(other.getSelectionShortcut());
        }
        if (characterFormRulesBuilder_ == null) {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRules_.isEmpty()) {
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00010000);
            } else {
              ensureCharacterFormRulesIsMutable();
              characterFormRules_.addAll(other.characterFormRules_);
            }
            onChanged();
          }
        } else {
          if (!other.characterFormRules_.isEmpty()) {
            if (characterFormRulesBuilder_.isEmpty()) {
              characterFormRulesBuilder_.dispose();
              characterFormRulesBuilder_ = null;
              characterFormRules_ = other.characterFormRules_;
              bitField0_ = (bitField0_ & ~0x00010000);
              characterFormRulesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getCharacterFormRulesFieldBuilder() : null;
            } else {
              characterFormRulesBuilder_.addAllMessages(other.characterFormRules_);
            }
          }
        }
        if (other.hasUseAutoImeTurnOff()) {
          setUseAutoImeTurnOff(other.getUseAutoImeTurnOff());
        }
        if (other.hasUseCascadingWindow()) {
          setUseCascadingWindow(other.getUseCascadingWindow());
        }
        if (other.hasShiftKeyModeSwitch()) {
          setShiftKeyModeSwitch(other.getShiftKeyModeSwitch());
        }
        if (other.hasNumpadCharacterForm()) {
          setNumpadCharacterForm(other.getNumpadCharacterForm());
        }
        if (other.hasUseAutoConversion()) {
          setUseAutoConversion(other.getUseAutoConversion());
        }
        if (other.hasAutoConversionKey()) {
          setAutoConversionKey(other.getAutoConversionKey());
        }
        if (other.hasYenSignCharacter()) {
          setYenSignCharacter(other.getYenSignCharacter());
        }
        if (other.hasUseJapaneseLayout()) {
          setUseJapaneseLayout(other.getUseJapaneseLayout());
        }
        if (other.hasUseKanaModifierInsensitiveConversion()) {
          setUseKanaModifierInsensitiveConversion(other.getUseKanaModifierInsensitiveConversion());
        }
        if (other.hasUseTypingCorrection()) {
          setUseTypingCorrection(other.getUseTypingCorrection());
        }
        if (other.hasUseDateConversion()) {
          setUseDateConversion(other.getUseDateConversion());
        }
        if (other.hasUseSingleKanjiConversion()) {
          setUseSingleKanjiConversion(other.getUseSingleKanjiConversion());
        }
        if (other.hasUseSymbolConversion()) {
          setUseSymbolConversion(other.getUseSymbolConversion());
        }
        if (other.hasUseNumberConversion()) {
          setUseNumberConversion(other.getUseNumberConversion());
        }
        if (other.hasUseEmoticonConversion()) {
          setUseEmoticonConversion(other.getUseEmoticonConversion());
        }
        if (other.hasUseCalculator()) {
          setUseCalculator(other.getUseCalculator());
        }
        if (other.hasUseT13NConversion()) {
          setUseT13NConversion(other.getUseT13NConversion());
        }
        if (other.hasUseZipCodeConversion()) {
          setUseZipCodeConversion(other.getUseZipCodeConversion());
        }
        if (other.hasUseSpellingCorrection()) {
          setUseSpellingCorrection(other.getUseSpellingCorrection());
        }
        if (other.hasUseEmojiConversion()) {
          setUseEmojiConversion(other.getUseEmojiConversion());
        }
        if (other.hasInformationListConfig()) {
          mergeInformationListConfig(other.getInformationListConfig());
        }
        if (other.hasUseHistorySuggest()) {
          setUseHistorySuggest(other.getUseHistorySuggest());
        }
        if (other.hasUseDictionarySuggest()) {
          setUseDictionarySuggest(other.getUseDictionarySuggest());
        }
        if (other.hasUseRealtimeConversion()) {
          setUseRealtimeConversion(other.getUseRealtimeConversion());
        }
        if (other.hasSuggestionsSize()) {
          setSuggestionsSize(other.getSuggestionsSize());
        }
        if (other.hasUseModeIndicator()) {
          setUseModeIndicator(other.getUseModeIndicator());
        }
        if (other.hasOBSOLETESyncConfig()) {
          mergeOBSOLETESyncConfig(other.getOBSOLETESyncConfig());
        }
        if (other.hasAllowCloudHandwriting()) {
          setAllowCloudHandwriting(other.getAllowCloudHandwriting());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      // optional .mozc.config.GeneralConfig general_config = 1;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig generalConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> generalConfigBuilder_;
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public boolean hasGeneralConfig() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig getGeneralConfig() {
        if (generalConfigBuilder_ == null) {
          return generalConfig_;
        } else {
          return generalConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public Builder setGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          generalConfig_ = value;
          onChanged();
        } else {
          generalConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public Builder setGeneralConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder builderForValue) {
        if (generalConfigBuilder_ == null) {
          generalConfig_ = builderForValue.build();
          onChanged();
        } else {
          generalConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public Builder mergeGeneralConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig value) {
        if (generalConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              generalConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance()) {
            generalConfig_ =
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.newBuilder(generalConfig_).mergeFrom(value).buildPartial();
          } else {
            generalConfig_ = value;
          }
          onChanged();
        } else {
          generalConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public Builder clearGeneralConfig() {
        if (generalConfigBuilder_ == null) {
          generalConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.getDefaultInstance();
          onChanged();
        } else {
          generalConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder getGeneralConfigBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getGeneralConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder getGeneralConfigOrBuilder() {
        if (generalConfigBuilder_ != null) {
          return generalConfigBuilder_.getMessageOrBuilder();
        } else {
          return generalConfig_;
        }
      }
      /**
       * <code>optional .mozc.config.GeneralConfig general_config = 1;</code>
       *
       * <pre>
       * General config and logging/debugging:
       * We won't use 2-9 and 20-39 ids anymore for historical reasons.
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder> 
          getGeneralConfigFieldBuilder() {
        if (generalConfigBuilder_ == null) {
          generalConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.GeneralConfigOrBuilder>(
                  generalConfig_,
                  getParentForChildren(),
                  isClean());
          generalConfig_ = null;
        }
        return generalConfigBuilder_;
      }

      // optional int32 verbose_level = 10 [default = 0];
      private int verboseLevel_ ;
      /**
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       *
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       */
      public boolean hasVerboseLevel() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       *
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       */
      public int getVerboseLevel() {
        return verboseLevel_;
      }
      /**
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       *
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       */
      public Builder setVerboseLevel(int value) {
        bitField0_ |= 0x00000002;
        verboseLevel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 verbose_level = 10 [default = 0];</code>
       *
       * <pre>
       * set verbose level of logging library (FLAGS_v)
       * </pre>
       */
      public Builder clearVerboseLevel() {
        bitField0_ = (bitField0_ & ~0x00000002);
        verboseLevel_ = 0;
        onChanged();
        return this;
      }

      // optional bool DEPRECATED_log_all_commands = 11 [default = false];
      private boolean dEPRECATEDLogAllCommands_ ;
      /**
       * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
       *
       * <pre>
       * This flag is not used
       * </pre>
       */
      public boolean hasDEPRECATEDLogAllCommands() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
       *
       * <pre>
       * This flag is not used
       * </pre>
       */
      public boolean getDEPRECATEDLogAllCommands() {
        return dEPRECATEDLogAllCommands_;
      }
      /**
       * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
       *
       * <pre>
       * This flag is not used
       * </pre>
       */
      public Builder setDEPRECATEDLogAllCommands(boolean value) {
        bitField0_ |= 0x00000004;
        dEPRECATEDLogAllCommands_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool DEPRECATED_log_all_commands = 11 [default = false];</code>
       *
       * <pre>
       * This flag is not used
       * </pre>
       */
      public Builder clearDEPRECATEDLogAllCommands() {
        bitField0_ = (bitField0_ & ~0x00000004);
        dEPRECATEDLogAllCommands_ = false;
        onChanged();
        return this;
      }

      // optional bool incognito_mode = 20 [default = false];
      private boolean incognitoMode_ ;
      /**
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       *
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       */
      public boolean hasIncognitoMode() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       *
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       */
      public boolean getIncognitoMode() {
        return incognitoMode_;
      }
      /**
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       *
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       */
      public Builder setIncognitoMode(boolean value) {
        bitField0_ |= 0x00000008;
        incognitoMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool incognito_mode = 20 [default = false];</code>
       *
       * <pre>
       * Incognito mode:
       * Disable all mutable operation if incognito_mode is true
       * </pre>
       */
      public Builder clearIncognitoMode() {
        bitField0_ = (bitField0_ & ~0x00000008);
        incognitoMode_ = false;
        onChanged();
        return this;
      }

      // optional bool check_default = 22 [default = true];
      private boolean checkDefault_ = true;
      /**
       * <code>optional bool check_default = 22 [default = true];</code>
       *
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       */
      public boolean hasCheckDefault() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bool check_default = 22 [default = true];</code>
       *
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       */
      public boolean getCheckDefault() {
        return checkDefault_;
      }
      /**
       * <code>optional bool check_default = 22 [default = true];</code>
       *
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       */
      public Builder setCheckDefault(boolean value) {
        bitField0_ |= 0x00000010;
        checkDefault_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool check_default = 22 [default = true];</code>
       *
       * <pre>
       * whether to show the set default dialog on startup
       * </pre>
       */
      public Builder clearCheckDefault() {
        bitField0_ = (bitField0_ & ~0x00000010);
        checkDefault_ = true;
        onChanged();
        return this;
      }

      // optional bool presentation_mode = 23 [default = false];
      private boolean presentationMode_ ;
      /**
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       *
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       */
      public boolean hasPresentationMode() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       *
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       */
      public boolean getPresentationMode() {
        return presentationMode_;
      }
      /**
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       *
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       */
      public Builder setPresentationMode(boolean value) {
        bitField0_ |= 0x00000020;
        presentationMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool presentation_mode = 23 [default = false];</code>
       *
       * <pre>
       * Presentation mode:
       * disable all suggestion temporally.
       * </pre>
       */
      public Builder clearPresentationMode() {
        bitField0_ = (bitField0_ & ~0x00000020);
        presentationMode_ = false;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod preeditMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN;
      /**
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       *
       * <pre>
       * Roman/Kana
       * </pre>
       */
      public boolean hasPreeditMethod() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       *
       * <pre>
       * Roman/Kana
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod getPreeditMethod() {
        return preeditMethod_;
      }
      /**
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       *
       * <pre>
       * Roman/Kana
       * </pre>
       */
      public Builder setPreeditMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000040;
        preeditMethod_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.PreeditMethod preedit_method = 40 [default = ROMAN];</code>
       *
       * <pre>
       * Roman/Kana
       * </pre>
       */
      public Builder clearPreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00000040);
        preeditMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PreeditMethod.ROMAN;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap sessionKeymap_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE;
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public boolean hasSessionKeymap() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap getSessionKeymap() {
        return sessionKeymap_;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public Builder setSessionKeymap(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000080;
        sessionKeymap_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SessionKeymap session_keymap = 41 [default = NONE];</code>
       */
      public Builder clearSessionKeymap() {
        bitField0_ = (bitField0_ & ~0x00000080);
        sessionKeymap_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SessionKeymap.NONE;
        onChanged();
        return this;
      }

      // optional bytes custom_keymap_table = 42;
      private com.google.protobuf.ByteString customKeymapTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes custom_keymap_table = 42;</code>
       *
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       */
      public boolean hasCustomKeymapTable() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional bytes custom_keymap_table = 42;</code>
       *
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       */
      public com.google.protobuf.ByteString getCustomKeymapTable() {
        return customKeymapTable_;
      }
      /**
       * <code>optional bytes custom_keymap_table = 42;</code>
       *
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       */
      public Builder setCustomKeymapTable(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        customKeymapTable_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes custom_keymap_table = 42;</code>
       *
       * <pre>
       * custom keymap
       * TODO(taku): replace it with repeated field
       * </pre>
       */
      public Builder clearCustomKeymapTable() {
        bitField0_ = (bitField0_ & ~0x00000100);
        customKeymapTable_ = getDefaultInstance().getCustomKeymapTable();
        onChanged();
        return this;
      }

      // optional bytes custom_roman_table = 43;
      private com.google.protobuf.ByteString customRomanTable_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes custom_roman_table = 43;</code>
       *
       * <pre>
       * custom roman table
       * </pre>
       */
      public boolean hasCustomRomanTable() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional bytes custom_roman_table = 43;</code>
       *
       * <pre>
       * custom roman table
       * </pre>
       */
      public com.google.protobuf.ByteString getCustomRomanTable() {
        return customRomanTable_;
      }
      /**
       * <code>optional bytes custom_roman_table = 43;</code>
       *
       * <pre>
       * custom roman table
       * </pre>
       */
      public Builder setCustomRomanTable(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000200;
        customRomanTable_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes custom_roman_table = 43;</code>
       *
       * <pre>
       * custom roman table
       * </pre>
       */
      public Builder clearCustomRomanTable() {
        bitField0_ = (bitField0_ & ~0x00000200);
        customRomanTable_ = getDefaultInstance().getCustomRomanTable();
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod punctuationMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN;
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public boolean hasPunctuationMethod() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod getPunctuationMethod() {
        return punctuationMethod_;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public Builder setPunctuationMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        punctuationMethod_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.PunctuationMethod punctuation_method = 45 [default = KUTEN_TOUTEN];</code>
       */
      public Builder clearPunctuationMethod() {
        bitField0_ = (bitField0_ & ~0x00000400);
        punctuationMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.PunctuationMethod.KUTEN_TOUTEN;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod symbolMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT;
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public boolean hasSymbolMethod() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod getSymbolMethod() {
        return symbolMethod_;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public Builder setSymbolMethod(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000800;
        symbolMethod_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SymbolMethod symbol_method = 46 [default = CORNER_BRACKET_MIDDLE_DOT];</code>
       */
      public Builder clearSymbolMethod() {
        bitField0_ = (bitField0_ & ~0x00000800);
        symbolMethod_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SymbolMethod.CORNER_BRACKET_MIDDLE_DOT;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm spaceCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE;
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public boolean hasSpaceCharacterForm() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm getSpaceCharacterForm() {
        return spaceCharacterForm_;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public Builder setSpaceCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00001000;
        spaceCharacterForm_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.FundamentalCharacterForm space_character_form = 47 [default = FUNDAMENTAL_INPUT_MODE];</code>
       */
      public Builder clearSpaceCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00001000);
        spaceCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.FundamentalCharacterForm.FUNDAMENTAL_INPUT_MODE;
        onChanged();
        return this;
      }

      // optional bool use_keyboard_to_change_preedit_method = 48 [default = false];
      private boolean useKeyboardToChangePreeditMethod_ ;
      /**
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       *
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       *
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       */
      public boolean hasUseKeyboardToChangePreeditMethod() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       *
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       *
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       */
      public boolean getUseKeyboardToChangePreeditMethod() {
        return useKeyboardToChangePreeditMethod_;
      }
      /**
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       *
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       *
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       */
      public Builder setUseKeyboardToChangePreeditMethod(boolean value) {
        bitField0_ |= 0x00002000;
        useKeyboardToChangePreeditMethod_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_keyboard_to_change_preedit_method = 48 [default = false];</code>
       *
       * <pre>
       * If this flag is true, Mozc toggles preedit method with some predefined
       * key events when IME is turned on.  Otherwise, Mozc ignores such kind of
       * key events so that their preferred can be preserved even when the toggle
       * key is pressed by accident.
       * As for Mozc, only Windows client supports such kind of toggle so this flag
       * is currently valid only on Windows.
       *
       * Background:
       *   Traditional Japanese IMEs have used "Roma-Ji" key in Japanese 106/109
       *   keyboard to toggle the preedit method between Roman and Kana style and
       *   this behavior was finally adopted into JIS X 4064:2002 as a basic
       *   functionality which is expected to support by a Japanese Input Method.
       *   However, people who are not aware of this functionality have been
       *   puzzled because the default key stroke is likely to be pressed
       *   by accident.
       * </pre>
       */
      public Builder clearUseKeyboardToChangePreeditMethod() {
        bitField0_ = (bitField0_ & ~0x00002000);
        useKeyboardToChangePreeditMethod_ = false;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel historyLearningLevel_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY;
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public boolean hasHistoryLearningLevel() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel getHistoryLearningLevel() {
        return historyLearningLevel_;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public Builder setHistoryLearningLevel(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00004000;
        historyLearningLevel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.HistoryLearningLevel history_learning_level = 50 [default = DEFAULT_HISTORY];</code>
       */
      public Builder clearHistoryLearningLevel() {
        bitField0_ = (bitField0_ & ~0x00004000);
        historyLearningLevel_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.HistoryLearningLevel.DEFAULT_HISTORY;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut selectionShortcut_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789;
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public boolean hasSelectionShortcut() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut getSelectionShortcut() {
        return selectionShortcut_;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public Builder setSelectionShortcut(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00008000;
        selectionShortcut_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.SelectionShortcut selection_shortcut = 52 [default = SHORTCUT_123456789];</code>
       */
      public Builder clearSelectionShortcut() {
        bitField0_ = (bitField0_ & ~0x00008000);
        selectionShortcut_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.SelectionShortcut.SHORTCUT_123456789;
        onChanged();
        return this;
      }

      // repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;
      private java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> characterFormRules_ =
        java.util.Collections.emptyList();
      private void ensureCharacterFormRulesIsMutable() {
        if (!((bitField0_ & 0x00010000) == 0x00010000)) {
          characterFormRules_ = new java.util.ArrayList<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule>(characterFormRules_);
          bitField0_ |= 0x00010000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> characterFormRulesBuilder_;

      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> getCharacterFormRulesList() {
        if (characterFormRulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        } else {
          return characterFormRulesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public int getCharacterFormRulesCount() {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.size();
        } else {
          return characterFormRulesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule getCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);
        } else {
          return characterFormRulesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder setCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.set(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule value) {
        if (characterFormRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, value);
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addCharacterFormRules(
          int index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder builderForValue) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.add(index, builderForValue.build());
          onChanged();
        } else {
          characterFormRulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder addAllCharacterFormRules(
          java.lang.Iterable<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule> values) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          super.addAll(values, characterFormRules_);
          onChanged();
        } else {
          characterFormRulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder clearCharacterFormRules() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00010000);
          onChanged();
        } else {
          characterFormRulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public Builder removeCharacterFormRules(int index) {
        if (characterFormRulesBuilder_ == null) {
          ensureCharacterFormRulesIsMutable();
          characterFormRules_.remove(index);
          onChanged();
        } else {
          characterFormRulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder getCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder getCharacterFormRulesOrBuilder(
          int index) {
        if (characterFormRulesBuilder_ == null) {
          return characterFormRules_.get(index);  } else {
          return characterFormRulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<? extends org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
           getCharacterFormRulesOrBuilderList() {
        if (characterFormRulesBuilder_ != null) {
          return characterFormRulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(characterFormRules_);
        }
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder() {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder addCharacterFormRulesBuilder(
          int index) {
        return getCharacterFormRulesFieldBuilder().addBuilder(
            index, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.getDefaultInstance());
      }
      /**
       * <code>repeated .mozc.config.Config.CharacterFormRule character_form_rules = 54;</code>
       */
      public java.util.List<org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder> 
           getCharacterFormRulesBuilderList() {
        return getCharacterFormRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder> 
          getCharacterFormRulesFieldBuilder() {
        if (characterFormRulesBuilder_ == null) {
          characterFormRulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRule.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.CharacterFormRuleOrBuilder>(
                  characterFormRules_,
                  ((bitField0_ & 0x00010000) == 0x00010000),
                  getParentForChildren(),
                  isClean());
          characterFormRules_ = null;
        }
        return characterFormRulesBuilder_;
      }

      // optional bool use_auto_ime_turn_off = 56 [default = true];
      private boolean useAutoImeTurnOff_ = true;
      /**
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       *
       * <pre>
       * auto IME turn off feature
       * </pre>
       */
      public boolean hasUseAutoImeTurnOff() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       *
       * <pre>
       * auto IME turn off feature
       * </pre>
       */
      public boolean getUseAutoImeTurnOff() {
        return useAutoImeTurnOff_;
      }
      /**
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       *
       * <pre>
       * auto IME turn off feature
       * </pre>
       */
      public Builder setUseAutoImeTurnOff(boolean value) {
        bitField0_ |= 0x00020000;
        useAutoImeTurnOff_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_auto_ime_turn_off = 56 [default = true];</code>
       *
       * <pre>
       * auto IME turn off feature
       * </pre>
       */
      public Builder clearUseAutoImeTurnOff() {
        bitField0_ = (bitField0_ & ~0x00020000);
        useAutoImeTurnOff_ = true;
        onChanged();
        return this;
      }

      // optional bool use_cascading_window = 58 [default = true];
      private boolean useCascadingWindow_ = true;
      /**
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       *
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       */
      public boolean hasUseCascadingWindow() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       *
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       */
      public boolean getUseCascadingWindow() {
        return useCascadingWindow_;
      }
      /**
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       *
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       */
      public Builder setUseCascadingWindow(boolean value) {
        bitField0_ |= 0x00040000;
        useCascadingWindow_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_cascading_window = 58 [default = true];</code>
       *
       * <pre>
       * Toggle to use cascanding window for debuging.
       * </pre>
       */
      public Builder clearUseCascadingWindow() {
        bitField0_ = (bitField0_ & ~0x00040000);
        useCascadingWindow_ = true;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch shiftKeyModeSwitch_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE;
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public boolean hasShiftKeyModeSwitch() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch getShiftKeyModeSwitch() {
        return shiftKeyModeSwitch_;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public Builder setShiftKeyModeSwitch(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00080000;
        shiftKeyModeSwitch_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.ShiftKeyModeSwitch shift_key_mode_switch = 59 [default = ASCII_INPUT_MODE];</code>
       */
      public Builder clearShiftKeyModeSwitch() {
        bitField0_ = (bitField0_ & ~0x00080000);
        shiftKeyModeSwitch_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.ShiftKeyModeSwitch.ASCII_INPUT_MODE;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm numpadCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH;
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public boolean hasNumpadCharacterForm() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm getNumpadCharacterForm() {
        return numpadCharacterForm_;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public Builder setNumpadCharacterForm(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00100000;
        numpadCharacterForm_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.NumpadCharacterForm numpad_character_form = 60 [default = NUMPAD_HALF_WIDTH];</code>
       */
      public Builder clearNumpadCharacterForm() {
        bitField0_ = (bitField0_ & ~0x00100000);
        numpadCharacterForm_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.NumpadCharacterForm.NUMPAD_HALF_WIDTH;
        onChanged();
        return this;
      }

      // optional bool use_auto_conversion = 61 [default = false];
      private boolean useAutoConversion_ ;
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public boolean hasUseAutoConversion() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public boolean getUseAutoConversion() {
        return useAutoConversion_;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public Builder setUseAutoConversion(boolean value) {
        bitField0_ |= 0x00200000;
        useAutoConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_auto_conversion = 61 [default = false];</code>
       */
      public Builder clearUseAutoConversion() {
        bitField0_ = (bitField0_ & ~0x00200000);
        useAutoConversion_ = false;
        onChanged();
        return this;
      }

      // optional uint32 auto_conversion_key = 62 [default = 13];
      private int autoConversionKey_ = 13;
      /**
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       *
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       */
      public boolean hasAutoConversionKey() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       *
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       */
      public int getAutoConversionKey() {
        return autoConversionKey_;
      }
      /**
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       *
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       */
      public Builder setAutoConversionKey(int value) {
        bitField0_ |= 0x00400000;
        autoConversionKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 auto_conversion_key = 62 [default = 13];</code>
       *
       * <pre>
       * can't use AutoConversionKey as a type since
       * undefined enum type is not correctly handled.
       * </pre>
       */
      public Builder clearAutoConversionKey() {
        bitField0_ = (bitField0_ & ~0x00400000);
        autoConversionKey_ = 13;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter yenSignCharacter_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN;
      /**
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       *
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       */
      public boolean hasYenSignCharacter() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       *
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter getYenSignCharacter() {
        return yenSignCharacter_;
      }
      /**
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       *
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       */
      public Builder setYenSignCharacter(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00800000;
        yenSignCharacter_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.YenSignCharacter yen_sign_character = 63 [default = YEN_SIGN];</code>
       *
       * <pre>
       * Mac-original JIS key layout has "yen-sign" key which generates
       * U+00A5 instead of U+005C and sometimes users get troubles with
       * them because they expect backslashes which are rendered as
       * yen-sign.  If this configuration is BACKSLASH, Mozc will
       * interpret U+005C even when the original key event is U+00A5.
       * </pre>
       */
      public Builder clearYenSignCharacter() {
        bitField0_ = (bitField0_ & ~0x00800000);
        yenSignCharacter_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.YenSignCharacter.YEN_SIGN;
        onChanged();
        return this;
      }

      // optional bool use_japanese_layout = 64 [default = false];
      private boolean useJapaneseLayout_ ;
      /**
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       *
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       */
      public boolean hasUseJapaneseLayout() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       *
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       */
      public boolean getUseJapaneseLayout() {
        return useJapaneseLayout_;
      }
      /**
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       *
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       */
      public Builder setUseJapaneseLayout(boolean value) {
        bitField0_ |= 0x01000000;
        useJapaneseLayout_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_japanese_layout = 64 [default = false];</code>
       *
       * <pre>
       * Use Japanese keyboard layout even when the user uses other
       * keyboard layouts.  In Mac OSX people can use several keyboard
       * layouts such like French or Spanish but some people want to use
       * Japanese layout for Japanese.  See http://b/2917320
       * </pre>
       */
      public Builder clearUseJapaneseLayout() {
        bitField0_ = (bitField0_ & ~0x01000000);
        useJapaneseLayout_ = false;
        onChanged();
        return this;
      }

      // optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];
      private boolean useKanaModifierInsensitiveConversion_ ;
      /**
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       *
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       */
      public boolean hasUseKanaModifierInsensitiveConversion() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       *
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       */
      public boolean getUseKanaModifierInsensitiveConversion() {
        return useKanaModifierInsensitiveConversion_;
      }
      /**
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       *
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       */
      public Builder setUseKanaModifierInsensitiveConversion(boolean value) {
        bitField0_ |= 0x02000000;
        useKanaModifierInsensitiveConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_kana_modifier_insensitive_conversion = 65 [default = false];</code>
       *
       * <pre>
       * Use kana modifier insensitive conversion.
       * e.g.  -&gt; 
       * Note that Request message has the same field.
       * - Request's one is controlled by the client. A user cannot control it.
       *   On the other hand Config's is under a user's control.
       * - Whether the feature is activated or not is decided by logical-AND
       *   of Request's and Config's.
       * </pre>
       */
      public Builder clearUseKanaModifierInsensitiveConversion() {
        bitField0_ = (bitField0_ & ~0x02000000);
        useKanaModifierInsensitiveConversion_ = false;
        onChanged();
        return this;
      }

      // optional bool use_typing_correction = 66 [default = false];
      private boolean useTypingCorrection_ ;
      /**
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       *
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       */
      public boolean hasUseTypingCorrection() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       *
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       */
      public boolean getUseTypingCorrection() {
        return useTypingCorrection_;
      }
      /**
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       *
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       */
      public Builder setUseTypingCorrection(boolean value) {
        bitField0_ |= 0x04000000;
        useTypingCorrection_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_typing_correction = 66 [default = false];</code>
       *
       * <pre>
       * Use typing correction feature.
       * e.g. sunkai -&gt; 
       * </pre>
       */
      public Builder clearUseTypingCorrection() {
        bitField0_ = (bitField0_ & ~0x04000000);
        useTypingCorrection_ = false;
        onChanged();
        return this;
      }

      // optional bool use_date_conversion = 80 [default = true];
      private boolean useDateConversion_ = true;
      /**
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Dictionary (80-99)
       * </pre>
       */
      public boolean hasUseDateConversion() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Dictionary (80-99)
       * </pre>
       */
      public boolean getUseDateConversion() {
        return useDateConversion_;
      }
      /**
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Dictionary (80-99)
       * </pre>
       */
      public Builder setUseDateConversion(boolean value) {
        bitField0_ |= 0x08000000;
        useDateConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_date_conversion = 80 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Dictionary (80-99)
       * </pre>
       */
      public Builder clearUseDateConversion() {
        bitField0_ = (bitField0_ & ~0x08000000);
        useDateConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_single_kanji_conversion = 81 [default = true];
      private boolean useSingleKanjiConversion_ = true;
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public boolean hasUseSingleKanjiConversion() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public boolean getUseSingleKanjiConversion() {
        return useSingleKanjiConversion_;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public Builder setUseSingleKanjiConversion(boolean value) {
        bitField0_ |= 0x10000000;
        useSingleKanjiConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_single_kanji_conversion = 81 [default = true];</code>
       */
      public Builder clearUseSingleKanjiConversion() {
        bitField0_ = (bitField0_ & ~0x10000000);
        useSingleKanjiConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_symbol_conversion = 82 [default = true];
      private boolean useSymbolConversion_ = true;
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public boolean hasUseSymbolConversion() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public boolean getUseSymbolConversion() {
        return useSymbolConversion_;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public Builder setUseSymbolConversion(boolean value) {
        bitField0_ |= 0x20000000;
        useSymbolConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_symbol_conversion = 82 [default = true];</code>
       */
      public Builder clearUseSymbolConversion() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useSymbolConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_number_conversion = 83 [default = true];
      private boolean useNumberConversion_ = true;
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public boolean hasUseNumberConversion() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public boolean getUseNumberConversion() {
        return useNumberConversion_;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public Builder setUseNumberConversion(boolean value) {
        bitField0_ |= 0x40000000;
        useNumberConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_number_conversion = 83 [default = true];</code>
       */
      public Builder clearUseNumberConversion() {
        bitField0_ = (bitField0_ & ~0x40000000);
        useNumberConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_emoticon_conversion = 84 [default = true];
      private boolean useEmoticonConversion_ = true;
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public boolean hasUseEmoticonConversion() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public boolean getUseEmoticonConversion() {
        return useEmoticonConversion_;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public Builder setUseEmoticonConversion(boolean value) {
        bitField0_ |= 0x80000000;
        useEmoticonConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_emoticon_conversion = 84 [default = true];</code>
       */
      public Builder clearUseEmoticonConversion() {
        bitField0_ = (bitField0_ & ~0x80000000);
        useEmoticonConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_calculator = 85 [default = true];
      private boolean useCalculator_ = true;
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public boolean hasUseCalculator() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public boolean getUseCalculator() {
        return useCalculator_;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public Builder setUseCalculator(boolean value) {
        bitField1_ |= 0x00000001;
        useCalculator_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_calculator = 85 [default = true];</code>
       */
      public Builder clearUseCalculator() {
        bitField1_ = (bitField1_ & ~0x00000001);
        useCalculator_ = true;
        onChanged();
        return this;
      }

      // optional bool use_t13n_conversion = 86 [default = true];
      private boolean useT13NConversion_ = true;
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public boolean hasUseT13NConversion() {
        return ((bitField1_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public boolean getUseT13NConversion() {
        return useT13NConversion_;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public Builder setUseT13NConversion(boolean value) {
        bitField1_ |= 0x00000002;
        useT13NConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_t13n_conversion = 86 [default = true];</code>
       */
      public Builder clearUseT13NConversion() {
        bitField1_ = (bitField1_ & ~0x00000002);
        useT13NConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_zip_code_conversion = 87 [default = true];
      private boolean useZipCodeConversion_ = true;
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public boolean hasUseZipCodeConversion() {
        return ((bitField1_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public boolean getUseZipCodeConversion() {
        return useZipCodeConversion_;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public Builder setUseZipCodeConversion(boolean value) {
        bitField1_ |= 0x00000004;
        useZipCodeConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_zip_code_conversion = 87 [default = true];</code>
       */
      public Builder clearUseZipCodeConversion() {
        bitField1_ = (bitField1_ & ~0x00000004);
        useZipCodeConversion_ = true;
        onChanged();
        return this;
      }

      // optional bool use_spelling_correction = 88 [default = true];
      private boolean useSpellingCorrection_ = true;
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public boolean hasUseSpellingCorrection() {
        return ((bitField1_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public boolean getUseSpellingCorrection() {
        return useSpellingCorrection_;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public Builder setUseSpellingCorrection(boolean value) {
        bitField1_ |= 0x00000008;
        useSpellingCorrection_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_spelling_correction = 88 [default = true];</code>
       */
      public Builder clearUseSpellingCorrection() {
        bitField1_ = (bitField1_ & ~0x00000008);
        useSpellingCorrection_ = true;
        onChanged();
        return this;
      }

      // optional bool use_emoji_conversion = 89 [default = false];
      private boolean useEmojiConversion_ ;
      /**
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public boolean hasUseEmojiConversion() {
        return ((bitField1_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public boolean getUseEmojiConversion() {
        return useEmojiConversion_;
      }
      /**
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public Builder setUseEmojiConversion(boolean value) {
        bitField1_ |= 0x00000010;
        useEmojiConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_emoji_conversion = 89 [default = false];</code>
       */
      public Builder clearUseEmojiConversion() {
        bitField1_ = (bitField1_ & ~0x00000010);
        useEmojiConversion_ = false;
        onChanged();
        return this;
      }

      // optional .mozc.config.Config.InformationListConfig information_list_config = 90;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig informationListConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> informationListConfigBuilder_;
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public boolean hasInformationListConfig() {
        return ((bitField1_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig getInformationListConfig() {
        if (informationListConfigBuilder_ == null) {
          return informationListConfig_;
        } else {
          return informationListConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          informationListConfig_ = value;
          onChanged();
        } else {
          informationListConfigBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder setInformationListConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder builderForValue) {
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = builderForValue.build();
          onChanged();
        } else {
          informationListConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder mergeInformationListConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig value) {
        if (informationListConfigBuilder_ == null) {
          if (((bitField1_ & 0x00000020) == 0x00000020) &&
              informationListConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance()) {
            informationListConfig_ =
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.newBuilder(informationListConfig_).mergeFrom(value).buildPartial();
          } else {
            informationListConfig_ = value;
          }
          onChanged();
        } else {
          informationListConfigBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public Builder clearInformationListConfig() {
        if (informationListConfigBuilder_ == null) {
          informationListConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.getDefaultInstance();
          onChanged();
        } else {
          informationListConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000020);
        return this;
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder getInformationListConfigBuilder() {
        bitField1_ |= 0x00000020;
        onChanged();
        return getInformationListConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder getInformationListConfigOrBuilder() {
        if (informationListConfigBuilder_ != null) {
          return informationListConfigBuilder_.getMessageOrBuilder();
        } else {
          return informationListConfig_;
        }
      }
      /**
       * <code>optional .mozc.config.Config.InformationListConfig information_list_config = 90;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder> 
          getInformationListConfigFieldBuilder() {
        if (informationListConfigBuilder_ == null) {
          informationListConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.Config.InformationListConfigOrBuilder>(
                  informationListConfig_,
                  getParentForChildren(),
                  isClean());
          informationListConfig_ = null;
        }
        return informationListConfigBuilder_;
      }

      // optional bool use_history_suggest = 100 [default = true];
      private boolean useHistorySuggest_ = true;
      /**
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Suggest (100-119)
       *
       * Use history-based suggest feature.
       * </pre>
       */
      public boolean hasUseHistorySuggest() {
        return ((bitField1_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Suggest (100-119)
       *
       * Use history-based suggest feature.
       * </pre>
       */
      public boolean getUseHistorySuggest() {
        return useHistorySuggest_;
      }
      /**
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Suggest (100-119)
       *
       * Use history-based suggest feature.
       * </pre>
       */
      public Builder setUseHistorySuggest(boolean value) {
        bitField1_ |= 0x00000040;
        useHistorySuggest_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_history_suggest = 100 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Suggest (100-119)
       *
       * Use history-based suggest feature.
       * </pre>
       */
      public Builder clearUseHistorySuggest() {
        bitField1_ = (bitField1_ & ~0x00000040);
        useHistorySuggest_ = true;
        onChanged();
        return this;
      }

      // optional bool use_dictionary_suggest = 101 [default = true];
      private boolean useDictionarySuggest_ = true;
      /**
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       *
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       */
      public boolean hasUseDictionarySuggest() {
        return ((bitField1_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       *
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       */
      public boolean getUseDictionarySuggest() {
        return useDictionarySuggest_;
      }
      /**
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       *
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       */
      public Builder setUseDictionarySuggest(boolean value) {
        bitField1_ |= 0x00000080;
        useDictionarySuggest_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_dictionary_suggest = 101 [default = true];</code>
       *
       * <pre>
       * Use dictionary-based suggest feature.
       * </pre>
       */
      public Builder clearUseDictionarySuggest() {
        bitField1_ = (bitField1_ & ~0x00000080);
        useDictionarySuggest_ = true;
        onChanged();
        return this;
      }

      // optional bool use_realtime_conversion = 102 [default = true];
      private boolean useRealtimeConversion_ = true;
      /**
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       *
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       */
      public boolean hasUseRealtimeConversion() {
        return ((bitField1_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       *
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       */
      public boolean getUseRealtimeConversion() {
        return useRealtimeConversion_;
      }
      /**
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       *
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       */
      public Builder setUseRealtimeConversion(boolean value) {
        bitField1_ |= 0x00000100;
        useRealtimeConversion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_realtime_conversion = 102 [default = true];</code>
       *
       * <pre>
       * Use realtime conversion feature.
       * </pre>
       */
      public Builder clearUseRealtimeConversion() {
        bitField1_ = (bitField1_ & ~0x00000100);
        useRealtimeConversion_ = true;
        onChanged();
        return this;
      }

      // optional uint32 suggestions_size = 110 [default = 3];
      private int suggestionsSize_ = 3;
      /**
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       *
       * <pre>
       * Size of suggestions.
       * </pre>
       */
      public boolean hasSuggestionsSize() {
        return ((bitField1_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       *
       * <pre>
       * Size of suggestions.
       * </pre>
       */
      public int getSuggestionsSize() {
        return suggestionsSize_;
      }
      /**
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       *
       * <pre>
       * Size of suggestions.
       * </pre>
       */
      public Builder setSuggestionsSize(int value) {
        bitField1_ |= 0x00000200;
        suggestionsSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 suggestions_size = 110 [default = 3];</code>
       *
       * <pre>
       * Size of suggestions.
       * </pre>
       */
      public Builder clearSuggestionsSize() {
        bitField1_ = (bitField1_ & ~0x00000200);
        suggestionsSize_ = 3;
        onChanged();
        return this;
      }

      // optional bool use_mode_indicator = 120 [default = true];
      private boolean useModeIndicator_ = true;
      /**
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Renderer (120-139)
       *
       * Use mode indicator feature.
       * </pre>
       */
      public boolean hasUseModeIndicator() {
        return ((bitField1_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Renderer (120-139)
       *
       * Use mode indicator feature.
       * </pre>
       */
      public boolean getUseModeIndicator() {
        return useModeIndicator_;
      }
      /**
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Renderer (120-139)
       *
       * Use mode indicator feature.
       * </pre>
       */
      public Builder setUseModeIndicator(boolean value) {
        bitField1_ |= 0x00000400;
        useModeIndicator_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_mode_indicator = 120 [default = true];</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Renderer (120-139)
       *
       * Use mode indicator feature.
       * </pre>
       */
      public Builder clearUseModeIndicator() {
        bitField1_ = (bitField1_ & ~0x00000400);
        useModeIndicator_ = true;
        onChanged();
        return this;
      }

      // optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;
      private org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig oBSOLETESyncConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder> oBSOLETESyncConfigBuilder_;
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public boolean hasOBSOLETESyncConfig() {
        return ((bitField1_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig getOBSOLETESyncConfig() {
        if (oBSOLETESyncConfigBuilder_ == null) {
          return oBSOLETESyncConfig_;
        } else {
          return oBSOLETESyncConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public Builder setOBSOLETESyncConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig value) {
        if (oBSOLETESyncConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oBSOLETESyncConfig_ = value;
          onChanged();
        } else {
          oBSOLETESyncConfigBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public Builder setOBSOLETESyncConfig(
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder builderForValue) {
        if (oBSOLETESyncConfigBuilder_ == null) {
          oBSOLETESyncConfig_ = builderForValue.build();
          onChanged();
        } else {
          oBSOLETESyncConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public Builder mergeOBSOLETESyncConfig(org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig value) {
        if (oBSOLETESyncConfigBuilder_ == null) {
          if (((bitField1_ & 0x00000800) == 0x00000800) &&
              oBSOLETESyncConfig_ != org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance()) {
            oBSOLETESyncConfig_ =
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.newBuilder(oBSOLETESyncConfig_).mergeFrom(value).buildPartial();
          } else {
            oBSOLETESyncConfig_ = value;
          }
          onChanged();
        } else {
          oBSOLETESyncConfigBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public Builder clearOBSOLETESyncConfig() {
        if (oBSOLETESyncConfigBuilder_ == null) {
          oBSOLETESyncConfig_ = org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.getDefaultInstance();
          onChanged();
        } else {
          oBSOLETESyncConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000800);
        return this;
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder getOBSOLETESyncConfigBuilder() {
        bitField1_ |= 0x00000800;
        onChanged();
        return getOBSOLETESyncConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      public org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder getOBSOLETESyncConfigOrBuilder() {
        if (oBSOLETESyncConfigBuilder_ != null) {
          return oBSOLETESyncConfigBuilder_.getMessageOrBuilder();
        } else {
          return oBSOLETESyncConfig_;
        }
      }
      /**
       * <code>optional .mozc.config.OBSOLETE_SyncConfig OBSOLETE_sync_config = 300;</code>
       *
       * <pre>
       *&#47;///////////////////////////////////////////////////////////
       *
       * Cloud (300-319)
       *
       * Configuration for cloud sync feature. This field is obsolete.
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder> 
          getOBSOLETESyncConfigFieldBuilder() {
        if (oBSOLETESyncConfigBuilder_ == null) {
          oBSOLETESyncConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfig.Builder, org.mozc.android.inputmethod.japanese.protobuf.ProtoConfig.OBSOLETE_SyncConfigOrBuilder>(
                  oBSOLETESyncConfig_,
                  getParentForChildren(),
                  isClean());
          oBSOLETESyncConfig_ = null;
        }
        return oBSOLETESyncConfigBuilder_;
      }

      // optional bool allow_cloud_handwriting = 301 [default = false];
      private boolean allowCloudHandwriting_ ;
      /**
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       *
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       */
      public boolean hasAllowCloudHandwriting() {
        return ((bitField1_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       *
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       */
      public boolean getAllowCloudHandwriting() {
        return allowCloudHandwriting_;
      }
      /**
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       *
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       */
      public Builder setAllowCloudHandwriting(boolean value) {
        bitField1_ |= 0x00001000;
        allowCloudHandwriting_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool allow_cloud_handwriting = 301 [default = false];</code>
       *
       * <pre>
       * Allow the cloud handwriting.  The handwriting UI has to notice
       * user before activating the feature, and set this field to true
       * when the user permit.
       * NOTE: OSS version does not handle this field.
       * </pre>
       */
      public Builder clearAllowCloudHandwriting() {
        bitField1_ = (bitField1_ & ~0x00001000);
        allowCloudHandwriting_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:mozc.config.Config)
    }

    static {
      defaultInstance = new Config(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:mozc.config.Config)
  }

  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_GeneralConfig_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_mozc_config_GeneralConfig_fieldAccessorTable;
  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_mozc_config_OBSOLETE_SyncConfig_fieldAccessorTable;
  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_mozc_config_Config_fieldAccessorTable;
  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_CharacterFormRule_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable;
  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_mozc_config_Config_InformationListConfig_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025protocol/config.proto\022\013mozc.config\"\305\001\n" +
      "\rGeneralConfig\022\031\n\016config_version\030\001 \001(\r:\001" +
      "0\022.\n\035last_modified_product_version\030\002 \001(\t" +
      ":\0070.0.0.0\022\035\n\022last_modified_time\030\003 \001(\004:\0010" +
      "\022\022\n\010platform\030\004 \001(\t:\000\022\023\n\tui_locale\030\005 \001(\t:" +
      "\000\022!\n\022upload_usage_stats\030\006 \001(\010:\005false\"\327\001\n" +
      "\023OBSOLETE_SyncConfig\022\036\n\017use_config_sync\030" +
      "\001 \001(\010:\005false\022\'\n\030use_user_dictionary_sync" +
      "\030\002 \001(\010:\005false\022$\n\025use_user_history_sync\030\003" +
      " \001(\010:\005false\022+\n\034use_learning_preference_s",
      "ync\030\004 \001(\010:\005false\022$\n\025use_contact_list_syn" +
      "c\030\005 \001(\010:\005false\"\276\034\n\006Config\0222\n\016general_con" +
      "fig\030\001 \001(\0132\032.mozc.config.GeneralConfig\022\030\n" +
      "\rverbose_level\030\n \001(\005:\0010\022*\n\033DEPRECATED_lo" +
      "g_all_commands\030\013 \001(\010:\005false\022\035\n\016incognito" +
      "_mode\030\024 \001(\010:\005false\022\033\n\rcheck_default\030\026 \001(" +
      "\010:\004true\022 \n\021presentation_mode\030\027 \001(\010:\005fals" +
      "e\022@\n\016preedit_method\030( \001(\0162!.mozc.config." +
      "Config.PreeditMethod:\005ROMAN\022?\n\016session_k" +
      "eymap\030) \001(\0162!.mozc.config.Config.Session",
      "Keymap:\004NONE\022\033\n\023custom_keymap_table\030* \001(" +
      "\014\022\032\n\022custom_roman_table\030+ \001(\014\022O\n\022punctua" +
      "tion_method\030- \001(\0162%.mozc.config.Config.P" +
      "unctuationMethod:\014KUTEN_TOUTEN\022R\n\rsymbol" +
      "_method\030. \001(\0162 .mozc.config.Config.Symbo" +
      "lMethod:\031CORNER_BRACKET_MIDDLE_DOT\022b\n\024sp" +
      "ace_character_form\030/ \001(\0162,.mozc.config.C" +
      "onfig.FundamentalCharacterForm:\026FUNDAMEN" +
      "TAL_INPUT_MODE\0224\n%use_keyboard_to_change" +
      "_preedit_method\0300 \001(\010:\005false\022Y\n\026history_",
      "learning_level\0302 \001(\0162(.mozc.config.Confi" +
      "g.HistoryLearningLevel:\017DEFAULT_HISTORY\022" +
      "U\n\022selection_shortcut\0304 \001(\0162%.mozc.confi" +
      "g.Config.SelectionShortcut:\022SHORTCUT_123" +
      "456789\022C\n\024character_form_rules\0306 \003(\0132%.m" +
      "ozc.config.Config.CharacterFormRule\022#\n\025u" +
      "se_auto_ime_turn_off\0308 \001(\010:\004true\022\"\n\024use_" +
      "cascading_window\030: \001(\010:\004true\022W\n\025shift_ke" +
      "y_mode_switch\030; \001(\0162&.mozc.config.Config" +
      ".ShiftKeyModeSwitch:\020ASCII_INPUT_MODE\022Y\n",
      "\025numpad_character_form\030< \001(\0162\'.mozc.conf" +
      "ig.Config.NumpadCharacterForm:\021NUMPAD_HA" +
      "LF_WIDTH\022\"\n\023use_auto_conversion\030= \001(\010:\005f" +
      "alse\022\037\n\023auto_conversion_key\030> \001(\r:\00213\022J\n" +
      "\022yen_sign_character\030? \001(\0162$.mozc.config." +
      "Config.YenSignCharacter:\010YEN_SIGN\022\"\n\023use" +
      "_japanese_layout\030@ \001(\010:\005false\0227\n(use_kan" +
      "a_modifier_insensitive_conversion\030A \001(\010:" +
      "\005false\022$\n\025use_typing_correction\030B \001(\010:\005f" +
      "alse\022!\n\023use_date_conversion\030P \001(\010:\004true\022",
      ")\n\033use_single_kanji_conversion\030Q \001(\010:\004tr" +
      "ue\022#\n\025use_symbol_conversion\030R \001(\010:\004true\022" +
      "#\n\025use_number_conversion\030S \001(\010:\004true\022%\n\027" +
      "use_emoticon_conversion\030T \001(\010:\004true\022\034\n\016u" +
      "se_calculator\030U \001(\010:\004true\022!\n\023use_t13n_co" +
      "nversion\030V \001(\010:\004true\022%\n\027use_zip_code_con" +
      "version\030W \001(\010:\004true\022%\n\027use_spelling_corr" +
      "ection\030X \001(\010:\004true\022#\n\024use_emoji_conversi" +
      "on\030Y \001(\010:\005false\022J\n\027information_list_conf" +
      "ig\030Z \001(\0132).mozc.config.Config.Informatio",
      "nListConfig\022!\n\023use_history_suggest\030d \001(\010" +
      ":\004true\022$\n\026use_dictionary_suggest\030e \001(\010:\004" +
      "true\022%\n\027use_realtime_conversion\030f \001(\010:\004t" +
      "rue\022\033\n\020suggestions_size\030n \001(\r:\0013\022 \n\022use_" +
      "mode_indicator\030x \001(\010:\004true\022?\n\024OBSOLETE_s" +
      "ync_config\030\254\002 \001(\0132 .mozc.config.OBSOLETE" +
      "_SyncConfig\022\'\n\027allow_cloud_handwriting\030\255" +
      "\002 \001(\010:\005false\032\303\001\n\021CharacterFormRule\022\r\n\005gr" +
      "oup\030\001 \001(\t\022M\n\026preedit_character_form\030\002 \001(" +
      "\0162!.mozc.config.Config.CharacterForm:\nFU",
      "LL_WIDTH\022P\n\031conversion_character_form\030\003 " +
      "\001(\0162!.mozc.config.Config.CharacterForm:\n" +
      "FULL_WIDTH\032A\n\025InformationListConfig\022(\n\032u" +
      "se_local_usage_dictionary\030\001 \001(\010:\004true\"$\n" +
      "\rPreeditMethod\022\t\n\005ROMAN\020\000\022\010\n\004KANA\020\001\"j\n\rS" +
      "essionKeymap\022\021\n\004NONE\020\377\377\377\377\377\377\377\377\377\001\022\n\n\006CUSTO" +
      "M\020\000\022\010\n\004ATOK\020\001\022\t\n\005MSIME\020\002\022\013\n\007KOTOERI\020\003\022\n\n" +
      "\006MOBILE\020\004\022\014\n\010CHROMEOS\020\005\"[\n\021PunctuationMe" +
      "thod\022\020\n\014KUTEN_TOUTEN\020\000\022\020\n\014COMMA_PERIOD\020\001" +
      "\022\020\n\014KUTEN_PERIOD\020\002\022\020\n\014COMMA_TOUTEN\020\003\"\200\001\n",
      "\014SymbolMethod\022\035\n\031CORNER_BRACKET_MIDDLE_D" +
      "OT\020\000\022\030\n\024SQUARE_BRACKET_SLASH\020\001\022\030\n\024CORNER" +
      "_BRACKET_SLASH\020\002\022\035\n\031SQUARE_BRACKET_MIDDL" +
      "E_DOT\020\003\"n\n\030FundamentalCharacterForm\022\032\n\026F" +
      "UNDAMENTAL_INPUT_MODE\020\000\022\032\n\026FUNDAMENTAL_F" +
      "ULL_WIDTH\020\001\022\032\n\026FUNDAMENTAL_HALF_WIDTH\020\002\"" +
      "J\n\024HistoryLearningLevel\022\023\n\017DEFAULT_HISTO" +
      "RY\020\000\022\r\n\tREAD_ONLY\020\001\022\016\n\nNO_HISTORY\020\002\"T\n\021S" +
      "electionShortcut\022\017\n\013NO_SHORTCUT\020\000\022\026\n\022SHO" +
      "RTCUT_123456789\020\001\022\026\n\022SHORTCUT_ASDFGHJKL\020",
      "\002\"Q\n\rCharacterForm\022\016\n\nHALF_WIDTH\020\000\022\016\n\nFU" +
      "LL_WIDTH\020\001\022\r\n\tLAST_FORM\020\002\022\021\n\rNO_CONVERSI" +
      "ON\020\003\"L\n\022ShiftKeyModeSwitch\022\007\n\003OFF\020\000\022\024\n\020A" +
      "SCII_INPUT_MODE\020\001\022\027\n\023KATAKANA_INPUT_MODE" +
      "\020\002\"s\n\023NumpadCharacterForm\022\025\n\021NUMPAD_INPU" +
      "T_MODE\020\000\022\025\n\021NUMPAD_FULL_WIDTH\020\001\022\025\n\021NUMPA" +
      "D_HALF_WIDTH\020\002\022\027\n\023NUMPAD_DIRECT_INPUT\020\003\"" +
      "\254\001\n\021AutoConversionKey\022\027\n\023AUTO_CONVERSION" +
      "_OFF\020\000\022\031\n\025AUTO_CONVERSION_KUTEN\020\001\022\032\n\026AUT" +
      "O_CONVERSION_TOUTEN\020\002\022!\n\035AUTO_CONVERSION",
      "_QUESTION_MARK\020\004\022$\n AUTO_CONVERSION_EXCL" +
      "AMATION_MARK\020\010\"/\n\020YenSignCharacter\022\014\n\010YE" +
      "N_SIGN\020\000\022\r\n\tBACKSLASH\020\001B=\n.org.mozc.andr" +
      "oid.inputmethod.japanese.protobufB\013Proto" +
      "Config"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          internal_static_mozc_config_GeneralConfig_descriptor =
            getDescriptor().getMessageTypes().get(0);
          internal_static_mozc_config_GeneralConfig_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_mozc_config_GeneralConfig_descriptor,
              new java.lang.String[] { "ConfigVersion", "LastModifiedProductVersion", "LastModifiedTime", "Platform", "UiLocale", "UploadUsageStats", });
          internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor =
            getDescriptor().getMessageTypes().get(1);
          internal_static_mozc_config_OBSOLETE_SyncConfig_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_mozc_config_OBSOLETE_SyncConfig_descriptor,
              new java.lang.String[] { "UseConfigSync", "UseUserDictionarySync", "UseUserHistorySync", "UseLearningPreferenceSync", "UseContactListSync", });
          internal_static_mozc_config_Config_descriptor =
            getDescriptor().getMessageTypes().get(2);
          internal_static_mozc_config_Config_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_mozc_config_Config_descriptor,
              new java.lang.String[] { "GeneralConfig", "VerboseLevel", "DEPRECATEDLogAllCommands", "IncognitoMode", "CheckDefault", "PresentationMode", "PreeditMethod", "SessionKeymap", "CustomKeymapTable", "CustomRomanTable", "PunctuationMethod", "SymbolMethod", "SpaceCharacterForm", "UseKeyboardToChangePreeditMethod", "HistoryLearningLevel", "SelectionShortcut", "CharacterFormRules", "UseAutoImeTurnOff", "UseCascadingWindow", "ShiftKeyModeSwitch", "NumpadCharacterForm", "UseAutoConversion", "AutoConversionKey", "YenSignCharacter", "UseJapaneseLayout", "UseKanaModifierInsensitiveConversion", "UseTypingCorrection", "UseDateConversion", "UseSingleKanjiConversion", "UseSymbolConversion", "UseNumberConversion", "UseEmoticonConversion", "UseCalculator", "UseT13NConversion", "UseZipCodeConversion", "UseSpellingCorrection", "UseEmojiConversion", "InformationListConfig", "UseHistorySuggest", "UseDictionarySuggest", "UseRealtimeConversion", "SuggestionsSize", "UseModeIndicator", "OBSOLETESyncConfig", "AllowCloudHandwriting", });
          internal_static_mozc_config_Config_CharacterFormRule_descriptor =
            internal_static_mozc_config_Config_descriptor.getNestedTypes().get(0);
          internal_static_mozc_config_Config_CharacterFormRule_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_mozc_config_Config_CharacterFormRule_descriptor,
              new java.lang.String[] { "Group", "PreeditCharacterForm", "ConversionCharacterForm", });
          internal_static_mozc_config_Config_InformationListConfig_descriptor =
            internal_static_mozc_config_Config_descriptor.getNestedTypes().get(1);
          internal_static_mozc_config_Config_InformationListConfig_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_mozc_config_Config_InformationListConfig_descriptor,
              new java.lang.String[] { "UseLocalUsageDictionary", });
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
